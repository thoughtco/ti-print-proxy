// This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

(function (modules) {
	'use strict';

	var resolve, getRequire, wmRequire, notFoundError, findFile
	  , extensions = {".js":[],".json":[],".css":[],".html":[]}
	  , envRequire = typeof require === 'function' ? require : null;

	notFoundError = function (path) {
		var error = new Error("Could not find module '" + path + "'");
		error.code = 'MODULE_NOT_FOUND';
		return error;
	};
	findFile = function (scope, name, extName) {
		var i, ext;
		if (typeof scope[name + extName] === 'function') return name + extName;
		for (i = 0; (ext = extensions[extName][i]); ++i) {
			if (typeof scope[name + ext] === 'function') return name + ext;
		}
		return null;
	};
	resolve = function (scope, tree, path, fullPath, state, id) {
		var name, dir, exports, module, fn, found, ext;
		path = path.split(/[\\/]/);
		name = path.pop();
		if ((name === '.') || (name === '..')) {
			path.push(name);
			name = '';
		}
		while ((dir = path.shift()) != null)  {
			if (!dir || (dir === '.')) continue;
			if (dir === '..') {
				scope = tree.pop();
				id = id.slice(0, id.lastIndexOf('/'));
			} else {
				tree.push(scope);
				scope = scope[dir];
				id += '/' + dir;
			}
			if (!scope) throw notFoundError(fullPath);
		}
		if (name && (typeof scope[name] !== 'function')) {
			found = findFile(scope, name, '.js');
			if (!found) found = findFile(scope, name, '.json');
			if (!found) found = findFile(scope, name, '.css');
			if (!found) found = findFile(scope, name, '.html');
			if (found) {
				name = found;
			} else if ((state !== 2) && (typeof scope[name] === 'object')) {
				tree.push(scope);
				scope = scope[name];
				id += '/' + name;
				name = '';
			}
		}
		if (!name) {
			if ((state !== 1) && scope[':mainpath:']) {
				return resolve(scope, tree, scope[':mainpath:'], fullPath, 1, id);
			}
			return resolve(scope, tree, 'index', fullPath, 2, id);
		}
		fn = scope[name];
		if (!fn) throw notFoundError(fullPath);
		if (fn.hasOwnProperty('module')) return fn.module.exports;
		exports = {};
		fn.module = module = { exports: exports, id: id + '/' + name };
		fn.call(exports, exports, module, getRequire(scope, tree, id));
		return module.exports;
	};
	wmRequire = function (scope, tree, fullPath, id) {
		var name, path = fullPath, t = fullPath.charAt(0), state = 0;
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = '/';
			tree = [];
		} else if (t !== '.') {
			name = path.indexOf('@') === 0 ? path.split('/', 2).join("/") : path.split('/', 1)[0];
			scope = modules[name];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = name;
			tree = [];
			path = path.slice(name.length + 1);
			if (!path) {
				path = scope[':mainpath:'];
				if (path) {
					state = 1;
				} else {
					path = 'index';
					state = 2;
				}
			}
		}
		return resolve(scope, tree, path, fullPath, state, id);
	};
	getRequire = function (scope, tree, id) {
		var localRequire = function (path) {
			return wmRequire(scope, [].concat(tree), path, id);
		};
		if (envRequire) localRequire.fromParentEnvironment = envRequire;
		return localRequire
	};
	return getRequire(modules, [], '');
})
({
	"testcafe-hammerhead": {
		"src": {
			"client": {
				"transport": {
					"consts.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.HANDLE_PORT_CMD = exports.SET_INITIAL_WORKER_SETTINGS_CMD = void 0;
						var SET_INITIAL_WORKER_SETTINGS_CMD = 'hammerhead|transport|set-initial-worker-settings';
						exports.SET_INITIAL_WORKER_SETTINGS_CMD = SET_INITIAL_WORKER_SETTINGS_CMD;
						var HANDLE_PORT_CMD = 'hammerhead|transport|handle-port';
						exports.HANDLE_PORT_CMD = HANDLE_PORT_CMD;
					}
				},
				"transport-worker": {
					"index.js": function (exports, module, require) {
						

						var _request = _interopRequireDefault(require("./request"));

						var _consts = require("../transport/consts");

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						var serviceMsgUrl = '';
						var sessionId = '';
						var msgQueue = {};

						function asyncServiceMsg(msg, callback) {
						  (0, _request.default)(serviceMsgUrl, msg, function (err, data) {
						    return callback({
						      err: err,
						      data: data
						    });
						  });
						}

						function queuedAsyncServiceMsg(msg, callback) {
						  if (!msgQueue[msg.cmd]) msgQueue[msg.cmd] = [];
						  msgQueue[msg.cmd].push({
						    msg: msg,
						    callback: callback
						  });

						  var asyncMsgCallback = function asyncMsgCallback(result) {
						    var queuedMsg = msgQueue[msg.cmd].shift();
						    queuedMsg.callback(result);
						    if (msgQueue[msg.cmd].length) asyncServiceMsg(msgQueue[msg.cmd][0].msg, asyncMsgCallback);
						  };

						  if (msgQueue[msg.cmd].length === 1) asyncServiceMsg(msg, asyncMsgCallback);
						}

						var messageListener = function messageListener(e) {
						  if (e.data.cmd === _consts.SET_INITIAL_WORKER_SETTINGS_CMD) {
						    var settings = e.data;
						    serviceMsgUrl = settings.serviceMsgUrl;
						    sessionId = settings.sessionId;
						  } else if (e.data.cmd === _consts.HANDLE_PORT_CMD) e.ports[0].onmessage = messageListener;else {
						    var msgWrapper = e.data;
						    var msg = msgWrapper.msg;

						    var callback = function callback(result) {
						      return e.target.postMessage({
						        id: msgWrapper.id,
						        result: result
						      });
						    };

						    msg.sessionId = sessionId;
						    if (msgWrapper.queued) queuedAsyncServiceMsg(msg, callback);else asyncServiceMsg(msg, callback);
						  }
						};

						self.addEventListener('message', messageListener);
					},
					"request.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.default = request;

						var _builtinHeaderNames = _interopRequireDefault(require("../../request-pipeline/builtin-header-names"));

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						function handleResolve(ctx, e) {
						  var xhr = e.target; // NOTE: The 500 status code is returned by server when an error occurred into service message handler

						  if (xhr.status === 500 && xhr.responseText) {
						    ctx.msg.disableResending = true;
						    handleReject(ctx, e);
						  } else ctx.callback(null, xhr.responseText && JSON.parse(xhr.responseText));
						}

						function handleReject(ctx, e) {
						  var xhr = e.target;

						  if (ctx.msg.disableResending) {
						    var errorMsg = "XHR request failed with " + xhr.status + " status code.";
						    if (xhr.responseText) errorMsg += "\nError message: " + xhr.responseText;
						    ctx.callback(errorMsg);
						  } else {
						    ctx.msg.disableResending = true;
						    request(ctx.url, ctx.msg, ctx.callback);
						  }
						}

						function handleEvent(e) {
						  var ctx = this;
						  if (e.type === 'load') handleResolve(ctx, e);else handleReject(ctx, e);
						}

						function request(url, msg, callback) {
						  var xhr = new XMLHttpRequest();
						  var ctx = {
						    url: url,
						    msg: msg,
						    callback: callback,
						    handleEvent: handleEvent
						  };
						  xhr.open('POST', url, true);
						  xhr.setRequestHeader(_builtinHeaderNames.default.cacheControl, 'no-cache, no-store, must-revalidate');
						  xhr.addEventListener('load', ctx);
						  xhr.addEventListener('abort', ctx);
						  xhr.addEventListener('error', ctx);
						  xhr.addEventListener('timeout', ctx);
						  xhr.send(JSON.stringify(msg));
						}

						module.exports = exports.default;
					}
				}
			},
			"request-pipeline": {
				"builtin-header-names.js": function (exports, module, require) {
					

					exports.__esModule = true;
					exports.default = void 0;
					// -------------------------------------------------------------
					// WARNING: this file is used by both the client and the server.
					// Do not use any browser or node-specific API!
					// -------------------------------------------------------------

					/* eslint hammerhead/proto-methods: 2 */
					var _default = {
					  authorization: 'authorization',
					  wwwAuthenticate: 'www-authenticate',
					  proxyAuthorization: 'proxy-authorization',
					  proxyAuthenticate: 'proxy-authenticate',
					  host: 'host',
					  referer: 'referer',
					  origin: 'origin',
					  contentLength: 'content-length',
					  cookie: 'cookie',
					  setCookie: 'set-cookie',
					  ifModifiedSince: 'if-modified-since',
					  ifNoneMatch: 'if-none-match',
					  contentType: 'content-type',
					  location: 'location',
					  xFrameOptions: 'x-frame-options',
					  sourceMap: 'sourcemap',
					  referrerPolicy: 'referrer-policy',
					  refresh: 'refresh',
					  link: 'link',
					  cacheControl: 'cache-control',
					  pragma: 'pragma',
					  eTag: 'etag',
					  contentDisposition: 'content-disposition',
					  accept: 'accept',
					  contentEncoding: 'content-encoding',
					  expires: 'expires',
					  accessControlAllowOrigin: 'access-control-allow-origin',
					  accessControlAllowCredentials: 'access-control-allow-credentials',
					  contentSecurityPolicy: 'content-security-policy',
					  contentSecurityPolicyReportOnly: 'content-security-policy-report-only',
					  xContentSecurityPolicy: 'x-content-security-policy',
					  xContentSecurityPolicyReportOnly: 'x-content-security-policy-report-only',
					  xWebkitCsp: 'x-webkit-csp'
					};
					exports.default = _default;
					module.exports = exports.default;
				}
			}
		}
	}
})("testcafe-hammerhead/src/client/transport-worker/index");
