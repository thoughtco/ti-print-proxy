'use strict';

exports.__esModule = true;

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _fs = require('fs');

var fs = _interopRequireWildcard(_fs);

var _path = require('path');

var path = _interopRequireWildcard(_path);

var _osFamily = require('os-family');

var _osFamily2 = _interopRequireDefault(_osFamily);

var _stripBom = require('strip-bom');

var _stripBom2 = _interopRequireDefault(_stripBom);

var _crypto = require('crypto');

var _url = require('url');

var _pinkie = require('pinkie');

var _pinkie2 = _interopRequireDefault(_pinkie);

var _legacy = require('./legacy');

var _requireReader = require('./require-reader');

var _requireReader2 = _interopRequireDefault(_requireReader);

var _promisify = require('../utils/promisify');

var _promisify2 = _interopRequireDefault(_promisify);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var readFile = (0, _promisify2.default)(fs.readFile);

function exists(filePath) {
    return new _pinkie2.default(resolve => fs.exists(filePath, resolve));
}

const FIXTURE_RE = /(^|;|\s+)('|")@fixture\s+.+?\2/;
const PAGE_RE = /(^|;|\s+)('|")@page\s+.+?\2/;
const TEST_RE = /(^|;|\s+)('|")@test\2\s*\[('|").+?\3\]\s*=\s*\{/;

class CompilerAdapter {
    constructor(hammerheadProcessScript) {
        this.cache = {
            requires: {},
            requireJsMap: {},
            sourceIndex: [],
            configs: {}
        };

        this.hammerheadProcessScript = hammerheadProcessScript;
        this.requireReader = new _requireReader2.default(this.cache.requires, this.hammerheadProcessScript);
    }

    static _resolveConfigModules(cfg, dirName) {
        if (cfg.modules) {
            (0, _keys2.default)(cfg.modules).forEach(name => {
                var mod = cfg.modules[name];

                if (Array.isArray(mod)) mod = mod.map(filePath => path.resolve(dirName, filePath));else mod = path.resolve(dirName, mod);

                cfg.modules[name] = mod;
            });
        }
    }

    static _collectDirConfigs(dirName) {
        return (0, _asyncToGenerator3.default)(function* () {
            var cfgs = [];

            var dirHierarchy = dirName.split(path.sep).reduce(function (dirs, chunk) {
                var dir = null;

                if (dirs.length) dir = path.join(dirs[dirs.length - 1], chunk);else if (_osFamily2.default.win) dir = chunk;else dir = path.sep + chunk;

                dirs.push(dir);

                return dirs;
            }, []);

            for (var _iterator = dirHierarchy, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var dir = _ref;

                var cfgPath = path.join(dir, 'test_config.json');
                var isExists = yield exists(cfgPath);

                if (isExists) {
                    var data = yield readFile(cfgPath);
                    var cfg = JSON.parse((0, _stripBom2.default)(data));

                    CompilerAdapter._resolveConfigModules(cfg, dir);
                    cfgs.push(cfg);
                }
            }

            return cfgs;
        })();
    }

    _getConfig(filePath) {
        var _this = this;

        return (0, _asyncToGenerator3.default)(function* () {
            var dirName = path.dirname(filePath);
            var cfg = {};
            var cachedCfg = _this.cache.configs[dirName];

            if (cachedCfg) cfg = cachedCfg;else {
                // NOTE: walk up in the directories hierarchy and collect test_config.json files
                var dirConfigs = yield CompilerAdapter._collectDirConfigs(dirName);

                cfg = {
                    modules: {},
                    baseUrl: ''
                };

                dirConfigs.forEach(function (dirCfg) {
                    if (dirCfg.modules) {
                        (0, _keys2.default)(dirCfg.modules).forEach(function (name) {
                            cfg.modules[name] = dirCfg.modules[name];
                        });
                    }

                    if (dirCfg.baseUrl) cfg.baseUrl = (0, _url.resolve)(cfg.baseUrl, dirCfg.baseUrl);
                });

                _this.cache.configs[dirName] = cfg;
            }

            return cfg;
        })();
    }

    _createLegacyCompilerPromise(code, filename, modules) {
        return new _pinkie2.default((resolve, reject) => {
            var legacyCompiler = new _legacy.Compiler(code, filename, modules, this.requireReader, this.cache.sourceIndex, this.hammerheadProcessScript);

            legacyCompiler.compile((errs, out) => {
                if (errs) {
                    var msg = 'There are test compilation errors:\n';

                    msg += errs.map(err => ` * ${(0, _legacy.getErrMsg)(err)}`).join('\n');

                    reject(new Error(msg));
                } else resolve(out);
            });
        });
    }

    _createTests(compiled, filePath, baseUrl, requireJsMapKey, remainderJs) {
        var fixture = {
            name: compiled.fixture,
            path: filePath,
            pageUrl: (0, _url.resolve)(baseUrl, compiled.page),
            authCredentials: compiled.authCredentials,
            getSharedJs: () => this.cache.requireJsMap[requireJsMapKey] + remainderJs
        };

        return (0, _keys2.default)(compiled.testsStepData).map(testName => ({
            name: testName,
            sourceIndex: this.cache.sourceIndex,
            stepData: compiled.testsStepData[testName],
            fixture: fixture,
            isLegacy: true,
            pageUrl: fixture.pageUrl,
            authCredentials: fixture.authCredentials
        }));
    }

    canCompile(code, filename) {
        return (/\.test\.js$/.test(filename) && FIXTURE_RE.test(code) && PAGE_RE.test(code) && TEST_RE.test(code)
        );
    }

    getSupportedExtension() {
        return '.test.js';
    }

    cleanUp() {
        // NOTE: Do nothing.
    }

    compile(code, filename) {
        var _this2 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            var _ref2 = yield _this2._getConfig(filename),
                modules = _ref2.modules,
                baseUrl = _ref2.baseUrl;

            var compiled = yield _this2._createLegacyCompilerPromise(code, filename, modules);

            //NOTE: solve memory overuse issue by storing requireJs in the suite-level hash-based map
            //(see: B237609 - Fixture file compiler memory overuse)
            var hash = (0, _crypto.createHash)('md5');
            var requireJsMap = _this2.cache.requireJsMap;
            var remainderJs = compiled.remainderJs;

            hash.update(compiled.requireJs);

            var requireJsMapKey = hash.digest('hex');

            if (!requireJsMap[requireJsMapKey]) requireJsMap[requireJsMapKey] = compiled.requireJs;

            return _this2._createTests(compiled, filename, baseUrl, requireJsMapKey, remainderJs);
        })();
    }
}
exports.default = CompilerAdapter;
module.exports = exports['default'];