"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.killBrowserProcess = void 0;
const child_process_1 = require("child_process");
const os_family_1 = __importDefault(require("os-family"));
const promisify_event_1 = __importDefault(require("promisify-event"));
const delay_1 = __importDefault(require("../utils/delay"));
const CHECK_PROCESS_IS_KILLED_TIMEOUT = 5000;
const CHECK_KILLED_DELAY = 1000;
const NEW_LINE_SEPERATOR_RE = /(\r\n)|(\n\r)|\n|\r/g;
const cannotGetListOfProcessError = 'Cannot get list of processes';
const killProcessTimeoutError = 'Kill process timeout';
function getProcessOutputUnix() {
    const error = new Error(cannotGetListOfProcessError);
    return new Promise((resolve, reject) => {
        const child = child_process_1.spawn('ps', ['-eo', 'pid,command']);
        let stdout = '';
        let stderr = '';
        child.stdout.on('data', data => {
            stdout += data.toString();
        });
        child.stderr.on('data', data => {
            stderr += data.toString();
        });
        child.on('exit', () => {
            if (stderr)
                reject(error);
            else
                resolve(stdout);
        });
        child.on('error', () => {
            reject(error);
        });
    });
}
function findProcessIdUnix(browserId, psOutput) {
    const processIdRegex = new RegExp('^\\s*(\\d+)\\s+.*' + browserId);
    const lines = psOutput.split(NEW_LINE_SEPERATOR_RE);
    for (let i = 0; i < lines.length; i++) {
        const match = processIdRegex.exec(lines[i]);
        if (match)
            return parseInt(match[1], 10);
    }
    return null;
}
function isProcessExistUnix(processId, psOutput) {
    const processIdRegex = new RegExp('^\\s*' + processId + '\\s+.*');
    const lines = psOutput.split(NEW_LINE_SEPERATOR_RE);
    return lines.some(line => processIdRegex.test(line));
}
async function findProcessUnix(browserId) {
    const output = await getProcessOutputUnix();
    return findProcessIdUnix(browserId, output);
}
async function checkUnixProcessIsKilled(processId) {
    const output = await getProcessOutputUnix();
    if (isProcessExistUnix(processId, output)) {
        await delay_1.default(CHECK_KILLED_DELAY);
        await checkUnixProcessIsKilled();
    }
}
async function killProcessUnix(processId) {
    let timeoutError = false;
    process.kill(processId);
    const killTimeoutTimer = delay_1.default(CHECK_PROCESS_IS_KILLED_TIMEOUT)
        .then(() => {
        timeoutError = true;
    });
    return Promise.race([killTimeoutTimer, checkUnixProcessIsKilled(processId)]).then(() => {
        if (timeoutError)
            throw new Error(killProcessTimeoutError);
    });
}
async function runWMIC(args) {
    const wmicProcess = child_process_1.spawn('wmic.exe', args, { detached: true });
    let wmicOutput = '';
    wmicProcess.stdout.on('data', data => {
        wmicOutput += data.toString();
    });
    try {
        await Promise.race([
            promisify_event_1.default(wmicProcess.stdout, 'end'),
            promisify_event_1.default(wmicProcess, 'error')
        ]);
        return wmicOutput;
    }
    catch (e) {
        return '';
    }
}
async function findProcessWin(browserId) {
    const wmicArgs = ['process', 'where', `commandline like '%${browserId}%' and name <> 'cmd.exe' and name <> 'wmic.exe'`, 'get', 'processid'];
    const wmicOutput = await runWMIC(wmicArgs);
    let processList = wmicOutput.split(/\s*\n/);
    processList = processList
        // NOTE: remove list's header and empty last element, caused by trailing newline
        .slice(1, -1)
        .map(pid => ({ pid: Number(pid) }));
    return processList[0] ? processList[0].pid : null;
}
async function killBrowserProcess(browserId) {
    const processId = os_family_1.default.win ? await findProcessWin(browserId) : await findProcessUnix(browserId);
    if (!processId)
        return true;
    try {
        if (os_family_1.default.win)
            process.kill(processId);
        else
            await killProcessUnix(processId);
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.killBrowserProcess = killBrowserProcess;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvY2Vzcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9wcm9jZXNzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGlEQUFzQztBQUN0QywwREFBMkI7QUFDM0Isc0VBQTZDO0FBQzdDLDJEQUFtQztBQUVuQyxNQUFNLCtCQUErQixHQUFHLElBQUksQ0FBQztBQUM3QyxNQUFNLGtCQUFrQixHQUFnQixJQUFJLENBQUM7QUFDN0MsTUFBTSxxQkFBcUIsR0FBYSxzQkFBc0IsQ0FBQztBQUMvRCxNQUFNLDJCQUEyQixHQUFPLDhCQUE4QixDQUFDO0FBQ3ZFLE1BQU0sdUJBQXVCLEdBQVcsc0JBQXNCLENBQUM7QUFFL0QsU0FBUyxvQkFBb0I7SUFDekIsTUFBTSxLQUFLLEdBQUcsSUFBSSxLQUFLLENBQUMsMkJBQTJCLENBQUMsQ0FBQztJQUVyRCxPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFO1FBQ25DLE1BQU0sS0FBSyxHQUFHLHFCQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsS0FBSyxFQUFFLGFBQWEsQ0FBQyxDQUFDLENBQUM7UUFDbEQsSUFBSSxNQUFNLEdBQUksRUFBRSxDQUFDO1FBQ2pCLElBQUksTUFBTSxHQUFJLEVBQUUsQ0FBQztRQUVqQixLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLEVBQUU7WUFDM0IsTUFBTSxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUM5QixDQUFDLENBQUMsQ0FBQztRQUVILEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsRUFBRTtZQUMzQixNQUFNLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQzlCLENBQUMsQ0FBQyxDQUFDO1FBRUgsS0FBSyxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFO1lB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UztJQUMvQyxNQUFNLFNBQVMsR0FBRyxtQkFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sZUFBZSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBRTlGLElBQUksQ0FBQyxTQUFTO1FBQ1YsT0FBTyxJQUFJLENBQUM7SUFFaEIsSUFBSTtRQUNBLElBQUksbUJBQUUsQ0FBQyxHQUFHO1lBQ04sT0FBTyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQzs7WUFFeEIsTUFBTSxlQUFlLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFckMsT0FBTyxJQUFJLENBQUM7S0FDZjtJQUNELE9BQU8sQ0FBQyxFQUFFO1FBQ04sT0FBTyxLQUFLLENBQUM7S0FDaEI7QUFDTCxDQUFDO0FBakJELGdEQWlCQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNwYXduIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgT1MgZnJvbSAnb3MtZmFtaWx5JztcbmltcG9ydCBwcm9taXNpZnlFdmVudCBmcm9tICdwcm9taXNpZnktZXZlbnQnO1xuaW1wb3J0IGRlbGF5IGZyb20gJy4uL3V0aWxzL2RlbGF5JztcblxuY29uc3QgQ0hFQ0tfUFJPQ0VTU19JU19LSUxMRURfVElNRU9VVCA9IDUwMDA7XG5jb25zdCBDSEVDS19LSUxMRURfREVMQVkgICAgICAgICAgICAgID0gMTAwMDtcbmNvbnN0IE5FV19MSU5FX1NFUEVSQVRPUl9SRSAgICAgICAgICAgPSAvKFxcclxcbil8KFxcblxccil8XFxufFxcci9nO1xuY29uc3QgY2Fubm90R2V0TGlzdE9mUHJvY2Vzc0Vycm9yICAgICA9ICdDYW5ub3QgZ2V0IGxpc3Qgb2YgcHJvY2Vzc2VzJztcbmNvbnN0IGtpbGxQcm9jZXNzVGltZW91dEVycm9yICAgICAgICAgPSAnS2lsbCBwcm9jZXNzIHRpbWVvdXQnO1xuXG5mdW5jdGlvbiBnZXRQcm9jZXNzT3V0cHV0VW5peCAoKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoY2Fubm90R2V0TGlzdE9mUHJvY2Vzc0Vycm9yKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gc3Bhd24oJ3BzJywgWyctZW8nLCAncGlkLGNvbW1hbmQnXSk7XG4gICAgICAgIGxldCBzdGRvdXQgID0gJyc7XG4gICAgICAgIGxldCBzdGRlcnIgID0gJyc7XG5cbiAgICAgICAgY2hpbGQuc3Rkb3V0Lm9uKCdkYXRhJywgZGF0YSA9PiB7XG4gICAgICAgICAgICBzdGRvdXQgKz0gZGF0YS50b1N0cmluZygpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjaGlsZC5zdGRlcnIub24oJ2RhdGEnLCBkYXRhID0+IHtcbiAgICAgICAgICAgIHN0ZGVyciArPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNoaWxkLm9uKCdleGl0JywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0ZGVycilcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlc29sdmUoc3Rkb3V0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2hpbGQub24oJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGZpbmRQcm9jZXNzSWRVbml4IChicm93c2VySWQsIHBzT3V0cHV0KSB7XG4gICAgY29uc3QgcHJvY2Vzc0lkUmVnZXggICA9IG5ldyBSZWdFeHAoJ15cXFxccyooXFxcXGQrKVxcXFxzKy4qJyArIGJyb3dzZXJJZCk7XG4gICAgY29uc3QgbGluZXMgICAgICAgICAgICA9IHBzT3V0cHV0LnNwbGl0KE5FV19MSU5FX1NFUEVSQVRPUl9SRSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gcHJvY2Vzc0lkUmVnZXguZXhlYyhsaW5lc1tpXSk7XG5cbiAgICAgICAgaWYgKG1hdGNoKVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzUHJvY2Vzc0V4aXN0VW5peCAocHJvY2Vzc0lkLCBwc091dHB1dCkge1xuICAgIGNvbnN0IHByb2Nlc3NJZFJlZ2V4ICAgPSBuZXcgUmVnRXhwKCdeXFxcXHMqJyArIHByb2Nlc3NJZCArICdcXFxccysuKicpO1xuICAgIGNvbnN0IGxpbmVzICAgICAgICAgICAgPSBwc091dHB1dC5zcGxpdChORVdfTElORV9TRVBFUkFUT1JfUkUpO1xuXG4gICAgcmV0dXJuIGxpbmVzLnNvbWUobGluZSA9PiBwcm9jZXNzSWRSZWdleC50ZXN0KGxpbmUpKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZmluZFByb2Nlc3NVbml4IChicm93c2VySWQpIHtcbiAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCBnZXRQcm9jZXNzT3V0cHV0VW5peCgpO1xuXG4gICAgcmV0dXJuIGZpbmRQcm9jZXNzSWRVbml4KGJyb3dzZXJJZCwgb3V0cHV0KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2hlY2tVbml4UHJvY2Vzc0lzS2lsbGVkIChwcm9jZXNzSWQpIHtcbiAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCBnZXRQcm9jZXNzT3V0cHV0VW5peCgpO1xuXG4gICAgaWYgKGlzUHJvY2Vzc0V4aXN0VW5peChwcm9jZXNzSWQsIG91dHB1dCkpIHtcbiAgICAgICAgYXdhaXQgZGVsYXkoQ0hFQ0tfS0lMTEVEX0RFTEFZKTtcblxuICAgICAgICBhd2FpdCBjaGVja1VuaXhQcm9jZXNzSXNLaWxsZWQoKTtcbiAgICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGtpbGxQcm9jZXNzVW5peCAocHJvY2Vzc0lkKSB7XG4gICAgbGV0IHRpbWVvdXRFcnJvciA9IGZhbHNlO1xuXG4gICAgcHJvY2Vzcy5raWxsKHByb2Nlc3NJZCk7XG5cbiAgICBjb25zdCBraWxsVGltZW91dFRpbWVyID0gZGVsYXkoQ0hFQ0tfUFJPQ0VTU19JU19LSUxMRURfVElNRU9VVClcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGltZW91dEVycm9yID0gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtraWxsVGltZW91dFRpbWVyLCBjaGVja1VuaXhQcm9jZXNzSXNLaWxsZWQocHJvY2Vzc0lkKV0pLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAodGltZW91dEVycm9yKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGtpbGxQcm9jZXNzVGltZW91dEVycm9yKTtcbiAgICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcnVuV01JQyAoYXJncykge1xuICAgIGNvbnN0IHdtaWNQcm9jZXNzID0gc3Bhd24oJ3dtaWMuZXhlJywgYXJncywgeyBkZXRhY2hlZDogdHJ1ZSB9KTtcblxuICAgIGxldCB3bWljT3V0cHV0ICA9ICcnO1xuXG4gICAgd21pY1Byb2Nlc3Muc3Rkb3V0Lm9uKCdkYXRhJywgZGF0YSA9PiB7XG4gICAgICAgIHdtaWNPdXRwdXQgKz0gZGF0YS50b1N0cmluZygpO1xuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgIHByb21pc2lmeUV2ZW50KHdtaWNQcm9jZXNzLnN0ZG91dCwgJ2VuZCcpLFxuICAgICAgICAgICAgcHJvbWlzaWZ5RXZlbnQod21pY1Byb2Nlc3MsICdlcnJvcicpXG4gICAgICAgIF0pO1xuXG4gICAgICAgIHJldHVybiB3bWljT3V0cHV0O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBmaW5kUHJvY2Vzc1dpbiAoYnJvd3NlcklkKSB7XG4gICAgY29uc3Qgd21pY0FyZ3MgICAgPSBbJ3Byb2Nlc3MnLCAnd2hlcmUnLCBgY29tbWFuZGxpbmUgbGlrZSAnJSR7YnJvd3NlcklkfSUnIGFuZCBuYW1lIDw+ICdjbWQuZXhlJyBhbmQgbmFtZSA8PiAnd21pYy5leGUnYCwgJ2dldCcsICdwcm9jZXNzaWQnXTtcbiAgICBjb25zdCB3bWljT3V0cHV0ICA9IGF3YWl0IHJ1bldNSUMod21pY0FyZ3MpO1xuICAgIGxldCBwcm9jZXNzTGlzdCA9IHdtaWNPdXRwdXQuc3BsaXQoL1xccypcXG4vKTtcblxuICAgIHByb2Nlc3NMaXN0ID0gcHJvY2Vzc0xpc3RcbiAgICAvLyBOT1RFOiByZW1vdmUgbGlzdCdzIGhlYWRlciBhbmQgZW1wdHkgbGFzdCBlbGVtZW50LCBjYXVzZWQgYnkgdHJhaWxpbmcgbmV3bGluZVxuICAgICAgICAuc2xpY2UoMSwgLTEpXG4gICAgICAgIC5tYXAocGlkID0+ICh7IHBpZDogTnVtYmVyKHBpZCkgfSkpO1xuXG4gICAgcmV0dXJuIHByb2Nlc3NMaXN0WzBdID8gcHJvY2Vzc0xpc3RbMF0ucGlkIDogbnVsbDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGtpbGxCcm93c2VyUHJvY2VzcyAoYnJvd3NlcklkKSB7XG4gICAgY29uc3QgcHJvY2Vzc0lkID0gT1Mud2luID8gYXdhaXQgZmluZFByb2Nlc3NXaW4oYnJvd3NlcklkKSA6IGF3YWl0IGZpbmRQcm9jZXNzVW5peChicm93c2VySWQpO1xuXG4gICAgaWYgKCFwcm9jZXNzSWQpXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKE9TLndpbilcbiAgICAgICAgICAgIHByb2Nlc3Mua2lsbChwcm9jZXNzSWQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBhd2FpdCBraWxsUHJvY2Vzc1VuaXgocHJvY2Vzc0lkKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbiJdfQ==