"use strict";
// -------------------------------------------------------------
// WARNING: this file is used by both the client and the server.
// Do not use any browser or node-specific API!
// -------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../types");
const DOCUMENTATION_LINKS = {
    TEST_SOURCE_PARAMETER: 'https://devexpress.github.io/testcafe/documentation/using-testcafe/command-line-interface.html#file-pathglob-pattern',
    FILTER_SETTINGS: 'https://devexpress.github.io/testcafe/documentation/using-testcafe/configuration-file.html#filter'
};
exports.default = {
    [types_1.RUNTIME_ERRORS.cannotCreateMultipleLiveModeRunners]: 'Cannot create multiple live mode runners.',
    [types_1.RUNTIME_ERRORS.cannotRunLiveModeRunnerMultipleTimes]: 'Cannot run a live mode runner multiple times.',
    [types_1.RUNTIME_ERRORS.browserDisconnected]: 'The {userAgent} browser disconnected. This problem may appear when a browser hangs or is closed, or due to network issues.',
    [types_1.RUNTIME_ERRORS.cannotRunAgainstDisconnectedBrowsers]: 'The following browsers disconnected: {userAgents}. Tests will not be run.',
    [types_1.RUNTIME_ERRORS.cannotEstablishBrowserConnection]: 'Unable to establish one or more of the specified browser connections. This can be caused by network issues or remote device failure.',
    [types_1.RUNTIME_ERRORS.cannotFindBrowser]: 'Unable to find the browser. "{browser}" is not a browser alias or path to an executable file.',
    [types_1.RUNTIME_ERRORS.browserProviderNotFound]: 'The specified "{providerName}" browser provider was not found.',
    [types_1.RUNTIME_ERRORS.browserNotSet]: 'No browser selected to test against.',
    [types_1.RUNTIME_ERRORS.testFilesNotFound]: 'TestCafe could not find the test files that match the following patterns:\n' +
        '{sourceList}\n\n' +
        'The "{cwd}" current working directory was used as the base path.\n' +
        'Ensure the file patterns are correct or change the current working directory.\n' +
        `For more information on how to specify test files, see ${DOCUMENTATION_LINKS.TEST_SOURCE_PARAMETER}.`,
    [types_1.RUNTIME_ERRORS.noTestsToRun]: 'No tests found in the specified source files.\n' +
        "Ensure the sources contain the 'fixture' and 'test' directives.",
    [types_1.RUNTIME_ERRORS.noTestsToRunDueFiltering]: 'The specified filter settings exclude all tests.\n' +
        'Modify these settings to leave at least one available test.\n' +
        `For more information on how to specify filter settings, see ${DOCUMENTATION_LINKS.FILTER_SETTINGS}.`,
    [types_1.RUNTIME_ERRORS.cannotFindReporterForAlias]: 'The provided "{name}" reporter does not exist. Check that you have specified the report format correctly.',
    [types_1.RUNTIME_ERRORS.multipleSameStreamReporters]: 'The following reporters attempted to write to the same output stream: "{reporters}". Only one reporter can write to a stream.',
    [types_1.RUNTIME_ERRORS.optionValueIsNotValidRegExp]: 'The "{optionName}" option value is not a valid regular expression.',
    [types_1.RUNTIME_ERRORS.optionValueIsNotValidKeyValue]: 'The "{optionName}" option value is not a valid key-value pair.',
    [types_1.RUNTIME_ERRORS.invalidSpeedValue]: 'Speed should be a number between 0.01 and 1.',
    [types_1.RUNTIME_ERRORS.invalidConcurrencyFactor]: 'The concurrency factor should be an integer greater or equal to 1.',
    [types_1.RUNTIME_ERRORS.cannotDivideRemotesCountByConcurrency]: 'The number of remote browsers should be divisible by the factor of concurrency.',
    [types_1.RUNTIME_ERRORS.portsOptionRequiresTwoNumbers]: 'The "--ports" option requires two numbers to be specified.',
    [types_1.RUNTIME_ERRORS.portIsNotFree]: 'The specified {portNum} port is already in use by another program.',
    [types_1.RUNTIME_ERRORS.invalidHostname]: 'The specified "{hostname}" hostname cannot be resolved to the current machine.',
    [types_1.RUNTIME_ERRORS.cannotFindSpecifiedTestSource]: 'Cannot find a test source file at "{path}".',
    [types_1.RUNTIME_ERRORS.clientFunctionCodeIsNotAFunction]: '{#instantiationCallsiteName} code is expected to be specified as a function, but {type} was passed.',
    [types_1.RUNTIME_ERRORS.selectorInitializedWithWrongType]: '{#instantiationCallsiteName} is expected to be initialized with a function, CSS selector string, another Selector, node snapshot or a Promise returned by a Selector, but {type} was passed.',
    [types_1.RUNTIME_ERRORS.clientFunctionCannotResolveTestRun]: "{#instantiationCallsiteName} cannot implicitly resolve the test run in context of which it should be executed. If you need to call {#instantiationCallsiteName} from the Node.js API callback, pass the test controller manually via {#instantiationCallsiteName}'s `.with({ boundTestRun: t })` method first. Note that you cannot execute {#instantiationCallsiteName} outside the test code.",
    [types_1.RUNTIME_ERRORS.regeneratorInClientFunctionCode]: `{#instantiationCallsiteName} code, arguments or dependencies cannot contain generators or "async/await" syntax (use Promises instead).`,
    [types_1.RUNTIME_ERRORS.invalidClientFunctionTestRunBinding]: 'The "boundTestRun" option value is expected to be a test controller.',
    [types_1.RUNTIME_ERRORS.invalidValueType]: '{smthg} is expected to be a {type}, but it was {actual}.',
    [types_1.RUNTIME_ERRORS.unsupportedUrlProtocol]: 'The specified "{url}" test page URL uses an unsupported {protocol}:// protocol. Only relative URLs or absolute URLs with http://, https:// and file:// protocols are supported.',
    [types_1.RUNTIME_ERRORS.testControllerProxyCannotResolveTestRun]: `Cannot implicitly resolve the test run in the context of which the test controller action should be executed. Use test function's 't' argument instead.`,
    [types_1.RUNTIME_ERRORS.timeLimitedPromiseTimeoutExpired]: 'Timeout expired for a time limited promise',
    [types_1.RUNTIME_ERRORS.cannotSetVideoOptionsWithoutBaseVideoPathSpecified]: 'Unable to set video or encoding options when video recording is disabled. Specify the base path where video files are stored to enable recording.',
    [types_1.RUNTIME_ERRORS.multipleAPIMethodCallForbidden]: 'You cannot call the "{methodName}" method more than once. Pass an array of parameters to this method instead.',
    [types_1.RUNTIME_ERRORS.invalidReporterOutput]: "Specify a file name or a writable stream as the reporter's output target.",
    [types_1.RUNTIME_ERRORS.cannotReadSSLCertFile]: 'Unable to read the "{path}" file, specified by the "{option}" ssl option. Error details:\n' +
        '\n' +
        '{err}',
    [types_1.RUNTIME_ERRORS.cannotPrepareTestsDueToError]: 'Cannot prepare tests due to an error.\n' +
        '\n' +
        '{errMessage}',
    [types_1.RUNTIME_ERRORS.cannotParseRawFile]: 'Cannot parse a test source file in the raw format at "{path}" due to an error.\n' +
        '\n' +
        '{errMessage}',
    [types_1.RUNTIME_ERRORS.testedAppFailedWithError]: 'Tested app failed with an error:\n' +
        '\n' +
        '{errMessage}',
    [types_1.RUNTIME_ERRORS.unableToOpenBrowser]: 'Was unable to open the browser "{alias}" due to error.\n' +
        '\n' +
        '{errMessage}',
    [types_1.RUNTIME_ERRORS.requestHookConfigureAPIError]: 'There was an error while configuring the request hook:\n' +
        '\n' +
        '{requestHookName}: {errMsg}',
    [types_1.RUNTIME_ERRORS.forbiddenCharatersInScreenshotPath]: 'There are forbidden characters in the "{screenshotPath}" {screenshotPathType}:\n' +
        ' {forbiddenCharsDescription}',
    [types_1.RUNTIME_ERRORS.cannotFindFFMPEG]: 'Unable to locate the FFmpeg executable required to record videos. Do one of the following:\n' +
        '\n' +
        '* add the FFmpeg installation directory to the PATH environment variable,\n' +
        '* specify the path to the FFmpeg executable in the FFMPEG_PATH environment variable or the ffmpegPath video option,\n' +
        '* install the @ffmpeg-installer/ffmpeg package from npm.',
    [types_1.RUNTIME_ERRORS.cannotFindTypescriptConfigurationFile]: 'Unable to find the TypeScript configuration file in "{filePath}"',
    [types_1.RUNTIME_ERRORS.clientScriptInitializerIsNotSpecified]: 'Specify the JavaScript file path, module name or script content to inject a client script.',
    [types_1.RUNTIME_ERRORS.clientScriptBasePathIsNotSpecified]: 'Specify the base path for the client script file.',
    [types_1.RUNTIME_ERRORS.clientScriptInitializerMultipleContentSources]: 'You cannot combine the file path, module name and script content when you specify a client script to inject.',
    [types_1.RUNTIME_ERRORS.cannotLoadClientScriptFromPath]: 'Cannot load a client script from {path}.',
    [types_1.RUNTIME_ERRORS.clientScriptModuleEntryPointPathCalculationError]: 'An error occurred when trying to locate the injected client script module:\n\n{errorMessage}.',
    [types_1.RUNTIME_ERRORS.methodIsNotAvailableForAnIPCHost]: 'This method cannot be called on a service host.',
    [types_1.RUNTIME_ERRORS.tooLargeIPCPayload]: 'The specified payload is too large to form an IPC packet.',
    [types_1.RUNTIME_ERRORS.malformedIPCMessage]: 'Cannot process a malformed IPC message.',
    [types_1.RUNTIME_ERRORS.unexpectedIPCHeadPacket]: 'Cannot create an IPC message due to an unexpected IPC head packet.',
    [types_1.RUNTIME_ERRORS.unexpectedIPCBodyPacket]: 'Cannot create an IPC message due to an unexpected IPC body packet.',
    [types_1.RUNTIME_ERRORS.unexpectedIPCTailPacket]: 'Cannot create an IPC message due to an unexpected IPC tail packet.',
    [types_1.RUNTIME_ERRORS.cannotUseAllowMultipleWindowsOptionForLegacyTests]: 'You cannot run Legacy API tests in multi-window mode.',
    [types_1.RUNTIME_ERRORS.cannotUseAllowMultipleWindowsOptionForSomeBrowsers]: 'You cannot use multi-window mode in {browsers}.'
};
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVtcGxhdGVzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2Vycm9ycy9ydW50aW1lL3RlbXBsYXRlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsZ0VBQWdFO0FBQ2hFLGdFQUFnRTtBQUNoRSwrQ0FBK0M7QUFDL0MsZ0VBQWdFOztBQUVoRSxvQ0FBMEM7QUFFMUMsTUFBTSxtQkFBbUIsR0FBRztJQUN4QixxQkFBcUIsRUFBRSxzSEFBc0g7SUFDN0ksZUFBZSxFQUFRLG1HQUFtRztDQUM3SCxDQUFDO0FBRUYsa0JBQWU7SUFDWCxDQUFDLHNCQUFjLENBQUMsbUNBQW1DLENBQUMsRUFBRywyQ0FBMkM7SUFDbEcsQ0FBQyxzQkFBYyxDQUFDLG9DQUFvQyxDQUFDLEVBQUUsK0NBQStDO0lBQ3RHLENBQUMsc0JBQWMsQ0FBQyxtQkFBbUIsQ0FBQyxFQUFtQiw0SEFBNEg7SUFDbkwsQ0FBQyxzQkFBYyxDQUFDLG9DQUFvQyxDQUFDLEVBQUUsMkVBQTJFO0lBQ2xJLENBQUMsc0JBQWMsQ0FBQyxnQ0FBZ0MsQ0FBQyxFQUFNLHNJQUFzSTtJQUM3TCxDQUFDLHNCQUFjLENBQUMsaUJBQWlCLENBQUMsRUFBcUIsK0ZBQStGO0lBQ3RKLENBQUMsc0JBQWMsQ0FBQyx1QkFBdUIsQ0FBQyxFQUFlLGdFQUFnRTtJQUN2SCxDQUFDLHNCQUFjLENBQUMsYUFBYSxDQUFDLEVBQXlCLHNDQUFzQztJQUU3RixDQUFDLHNCQUFjLENBQUMsaUJBQWlCLENBQUMsRUFBRSw2RUFBNkU7UUFDN0Usa0JBQWtCO1FBQ2xCLG9FQUFvRTtRQUNwRSxpRkFBaUY7UUFDakYsMERBQTBELG1CQUFtQixDQUFDLHFCQUFxQixHQUFHO0lBRTFJLENBQUMsc0JBQWMsQ0FBQyxZQUFZLENBQUMsRUFBRSxpREFBaUQ7UUFDakQsaUVBQWlFO0lBRWhHLENBQUMsc0JBQWMsQ0FBQyx3QkFBd0IsQ0FBQyxFQUFFLG9EQUFvRDtRQUNwRCwrREFBK0Q7UUFDL0Qs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O0lBQ3hILENBQUMsc0JBQWMsQ0FBQyw2Q0FBNkMsQ0FBQyxFQUFPLDhHQUE4RztJQUNuTCxDQUFDLHNCQUFjLENBQUMsOEJBQThCLENBQUMsRUFBc0IsMENBQTBDO0lBQy9HLENBQUMsc0JBQWMsQ0FBQyxnREFBZ0QsQ0FBQyxFQUFJLCtGQUErRjtJQUNwSyxDQUFDLHNCQUFjLENBQUMsZ0NBQWdDLENBQUMsRUFBb0IsaURBQWlEO0lBQ3RILENBQUMsc0JBQWMsQ0FBQyxrQkFBa0IsQ0FBQyxFQUFrQywyREFBMkQ7SUFDaEksQ0FBQyxzQkFBYyxDQUFDLG1CQUFtQixDQUFDLEVBQWlDLHlDQUF5QztJQUM5RyxDQUFDLHNCQUFjLENBQUMsdUJBQXVCLENBQUMsRUFBNkIsb0VBQW9FO0lBQ3pJLENBQUMsc0JBQWMsQ0FBQyx1QkFBdUIsQ0FBQyxFQUE2QixvRUFBb0U7SUFDekksQ0FBQyxzQkFBYyxDQUFDLHVCQUF1QixDQUFDLEVBQTZCLG9FQUFvRTtJQUN6SSxDQUFDLHNCQUFjLENBQUMsaURBQWlELENBQUMsRUFBRyx1REFBdUQ7SUFDNUgsQ0FBQyxzQkFBYyxDQUFDLGtEQUFrRCxDQUFDLEVBQUUsaURBQWlEO0NBQ3pILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBXQVJOSU5HOiB0aGlzIGZpbGUgaXMgdXNlZCBieSBib3RoIHRoZSBjbGllbnQgYW5kIHRoZSBzZXJ2ZXIuXG4vLyBEbyBub3QgdXNlIGFueSBicm93c2VyIG9yIG5vZGUtc3BlY2lmaWMgQVBJIVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5pbXBvcnQgeyBSVU5USU1FX0VSUk9SUyB9IGZyb20gJy4uL3R5cGVzJztcblxuY29uc3QgRE9DVU1FTlRBVElPTl9MSU5LUyA9IHtcbiAgICBURVNUX1NPVVJDRV9QQVJBTUVURVI6ICdodHRwczovL2RldmV4cHJlc3MuZ2l0aHViLmlvL3Rlc3RjYWZlL2RvY3VtZW50YXRpb24vdXNpbmctdGVzdGNhZmUvY29tbWFuZC1saW5lLWludGVyZmFjZS5odG1sI2ZpbGUtcGF0aGdsb2ItcGF0dGVybicsXG4gICAgRklMVEVSX1NFVFRJTkdTOiAgICAgICAnaHR0cHM6Ly9kZXZleHByZXNzLmdpdGh1Yi5pby90ZXN0Y2FmZS9kb2N1bWVudGF0aW9uL3VzaW5nLXRlc3RjYWZlL2NvbmZpZ3VyYXRpb24tZmlsZS5odG1sI2ZpbHRlcidcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90Q3JlYXRlTXVsdGlwbGVMaXZlTW9kZVJ1bm5lcnNdOiAgJ0Nhbm5vdCBjcmVhdGUgbXVsdGlwbGUgbGl2ZSBtb2RlIHJ1bm5lcnMuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90UnVuTGl2ZU1vZGVSdW5uZXJNdWx0aXBsZVRpbWVzXTogJ0Nhbm5vdCBydW4gYSBsaXZlIG1vZGUgcnVubmVyIG11bHRpcGxlIHRpbWVzLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmJyb3dzZXJEaXNjb25uZWN0ZWRdOiAgICAgICAgICAgICAgICAgICdUaGUge3VzZXJBZ2VudH0gYnJvd3NlciBkaXNjb25uZWN0ZWQuIFRoaXMgcHJvYmxlbSBtYXkgYXBwZWFyIHdoZW4gYSBicm93c2VyIGhhbmdzIG9yIGlzIGNsb3NlZCwgb3IgZHVlIHRvIG5ldHdvcmsgaXNzdWVzLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdFJ1bkFnYWluc3REaXNjb25uZWN0ZWRCcm93c2Vyc106ICdUaGUgZm9sbG93aW5nIGJyb3dzZXJzIGRpc2Nvbm5lY3RlZDoge3VzZXJBZ2VudHN9LiBUZXN0cyB3aWxsIG5vdCBiZSBydW4uJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90RXN0YWJsaXNoQnJvd3NlckNvbm5lY3Rpb25dOiAgICAgJ1VuYWJsZSB0byBlc3RhYmxpc2ggb25lIG9yIG1vcmUgb2YgdGhlIHNwZWNpZmllZCBicm93c2VyIGNvbm5lY3Rpb25zLiBUaGlzIGNhbiBiZSBjYXVzZWQgYnkgbmV0d29yayBpc3N1ZXMgb3IgcmVtb3RlIGRldmljZSBmYWlsdXJlLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdEZpbmRCcm93c2VyXTogICAgICAgICAgICAgICAgICAgICdVbmFibGUgdG8gZmluZCB0aGUgYnJvd3Nlci4gXCJ7YnJvd3Nlcn1cIiBpcyBub3QgYSBicm93c2VyIGFsaWFzIG9yIHBhdGggdG8gYW4gZXhlY3V0YWJsZSBmaWxlLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmJyb3dzZXJQcm92aWRlck5vdEZvdW5kXTogICAgICAgICAgICAgICdUaGUgc3BlY2lmaWVkIFwie3Byb3ZpZGVyTmFtZX1cIiBicm93c2VyIHByb3ZpZGVyIHdhcyBub3QgZm91bmQuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuYnJvd3Nlck5vdFNldF06ICAgICAgICAgICAgICAgICAgICAgICAgJ05vIGJyb3dzZXIgc2VsZWN0ZWQgdG8gdGVzdCBhZ2FpbnN0LicsXG5cbiAgICBbUlVOVElNRV9FUlJPUlMudGVzdEZpbGVzTm90Rm91bmRdOiAnVGVzdENhZmUgY291bGQgbm90IGZpbmQgdGhlIHRlc3QgZmlsZXMgdGhhdCBtYXRjaCB0aGUgZm9sbG93aW5nIHBhdHRlcm5zOlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7c291cmNlTGlzdH1cXG5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIFwie2N3ZH1cIiBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5IHdhcyB1c2VkIGFzIHRoZSBiYXNlIHBhdGguXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Vuc3VyZSB0aGUgZmlsZSBwYXR0ZXJucyBhcmUgY29ycmVjdCBvciBjaGFuZ2UgdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGhvdyB0byBzcGVjaWZ5IHRlc3QgZmlsZXMsIHNlZSAke0RPQ1VNRU5UQVRJT05fTElOS1MuVEVTVF9TT1VSQ0VfUEFSQU1FVEVSfS5gLFxuXG4gICAgW1JVTlRJTUVfRVJST1JTLm5vVGVzdHNUb1J1bl06ICdObyB0ZXN0cyBmb3VuZCBpbiB0aGUgc3BlY2lmaWVkIHNvdXJjZSBmaWxlcy5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJFbnN1cmUgdGhlIHNvdXJjZXMgY29udGFpbiB0aGUgJ2ZpeHR1cmUnIGFuZCAndGVzdCcgZGlyZWN0aXZlcy5cIixcblxuICAgIFtSVU5USU1FX0VSUk9SUy5ub1Rlc3RzVG9SdW5EdWVGaWx0ZXJpbmddOiAnVGhlIHNwZWNpZmllZCBmaWx0ZXIgc2V0dGluZ3MgZXhjbHVkZSBhbGwgdGVzdHMuXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdNb2RpZnkgdGhlc2Ugc2V0dGluZ3MgdG8gbGVhdmUgYXQgbGVhc3Qgb25lIGF2YWlsYWJsZSB0ZXN0LlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRvIHNwZWNpZnkgZmlsdGVyIHNldHRpbmdzLCBzZWUgJHtET0NVTUVOVEFUSU9OX0xJTktTLkZJTFRFUl9TRVRUSU5HU30uYCxcblxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RGaW5kUmVwb3J0ZXJGb3JBbGlhc106ICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgcHJvdmlkZWQgXCJ7bmFtZX1cIiByZXBvcnRlciBkb2VzIG5vdCBleGlzdC4gQ2hlY2sgdGhhdCB5b3UgaGF2ZSBzcGVjaWZpZWQgdGhlIHJlcG9ydCBmb3JtYXQgY29ycmVjdGx5LicsXG4gICAgW1JVTlRJTUVfRVJST1JTLm11bHRpcGxlU2FtZVN0cmVhbVJlcG9ydGVyc106ICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBmb2xsb3dpbmcgcmVwb3J0ZXJzIGF0dGVtcHRlZCB0byB3cml0ZSB0byB0aGUgc2FtZSBvdXRwdXQgc3RyZWFtOiBcIntyZXBvcnRlcnN9XCIuIE9ubHkgb25lIHJlcG9ydGVyIGNhbiB3cml0ZSB0byBhIHN0cmVhbS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5vcHRpb25WYWx1ZUlzTm90VmFsaWRSZWdFeHBdOiAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgXCJ7b3B0aW9uTmFtZX1cIiBvcHRpb24gdmFsdWUgaXMgbm90IGEgdmFsaWQgcmVndWxhciBleHByZXNzaW9uLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLm9wdGlvblZhbHVlSXNOb3RWYWxpZEtleVZhbHVlXTogICAgICAgICAgICAgICAgICAgICAgJ1RoZSBcIntvcHRpb25OYW1lfVwiIG9wdGlvbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCBrZXktdmFsdWUgcGFpci4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5pbnZhbGlkU3BlZWRWYWx1ZV06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdTcGVlZCBzaG91bGQgYmUgYSBudW1iZXIgYmV0d2VlbiAwLjAxIGFuZCAxLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmludmFsaWRDb25jdXJyZW5jeUZhY3Rvcl06ICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBjb25jdXJyZW5jeSBmYWN0b3Igc2hvdWxkIGJlIGFuIGludGVnZXIgZ3JlYXRlciBvciBlcXVhbCB0byAxLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdERpdmlkZVJlbW90ZXNDb3VudEJ5Q29uY3VycmVuY3ldOiAgICAgICAgICAgICAgJ1RoZSBudW1iZXIgb2YgcmVtb3RlIGJyb3dzZXJzIHNob3VsZCBiZSBkaXZpc2libGUgYnkgdGhlIGZhY3RvciBvZiBjb25jdXJyZW5jeS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5wb3J0c09wdGlvblJlcXVpcmVzVHdvTnVtYmVyc106ICAgICAgICAgICAgICAgICAgICAgICdUaGUgXCItLXBvcnRzXCIgb3B0aW9uIHJlcXVpcmVzIHR3byBudW1iZXJzIHRvIGJlIHNwZWNpZmllZC4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5wb3J0SXNOb3RGcmVlXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgc3BlY2lmaWVkIHtwb3J0TnVtfSBwb3J0IGlzIGFscmVhZHkgaW4gdXNlIGJ5IGFub3RoZXIgcHJvZ3JhbS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5pbnZhbGlkSG9zdG5hbWVdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgc3BlY2lmaWVkIFwie2hvc3RuYW1lfVwiIGhvc3RuYW1lIGNhbm5vdCBiZSByZXNvbHZlZCB0byB0aGUgY3VycmVudCBtYWNoaW5lLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdEZpbmRTcGVjaWZpZWRUZXN0U291cmNlXTogICAgICAgICAgICAgICAgICAgICAgJ0Nhbm5vdCBmaW5kIGEgdGVzdCBzb3VyY2UgZmlsZSBhdCBcIntwYXRofVwiLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNsaWVudEZ1bmN0aW9uQ29kZUlzTm90QUZ1bmN0aW9uXTogICAgICAgICAgICAgICAgICAgJ3sjaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0gY29kZSBpcyBleHBlY3RlZCB0byBiZSBzcGVjaWZpZWQgYXMgYSBmdW5jdGlvbiwgYnV0IHt0eXBlfSB3YXMgcGFzc2VkLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLnNlbGVjdG9ySW5pdGlhbGl6ZWRXaXRoV3JvbmdUeXBlXTogICAgICAgICAgICAgICAgICAgJ3sjaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0gaXMgZXhwZWN0ZWQgdG8gYmUgaW5pdGlhbGl6ZWQgd2l0aCBhIGZ1bmN0aW9uLCBDU1Mgc2VsZWN0b3Igc3RyaW5nLCBhbm90aGVyIFNlbGVjdG9yLCBub2RlIHNuYXBzaG90IG9yIGEgUHJvbWlzZSByZXR1cm5lZCBieSBhIFNlbGVjdG9yLCBidXQge3R5cGV9IHdhcyBwYXNzZWQuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2xpZW50RnVuY3Rpb25DYW5ub3RSZXNvbHZlVGVzdFJ1bl06ICAgICAgICAgICAgICAgICBcInsjaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0gY2Fubm90IGltcGxpY2l0bHkgcmVzb2x2ZSB0aGUgdGVzdCBydW4gaW4gY29udGV4dCBvZiB3aGljaCBpdCBzaG91bGQgYmUgZXhlY3V0ZWQuIElmIHlvdSBuZWVkIHRvIGNhbGwgeyNpbnN0YW50aWF0aW9uQ2FsbHNpdGVOYW1lfSBmcm9tIHRoZSBOb2RlLmpzIEFQSSBjYWxsYmFjaywgcGFzcyB0aGUgdGVzdCBjb250cm9sbGVyIG1hbnVhbGx5IHZpYSB7I2luc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWV9J3MgYC53aXRoKHsgYm91bmRUZXN0UnVuOiB0IH0pYCBtZXRob2QgZmlyc3QuIE5vdGUgdGhhdCB5b3UgY2Fubm90IGV4ZWN1dGUgeyNpbnN0YW50aWF0aW9uQ2FsbHNpdGVOYW1lfSBvdXRzaWRlIHRoZSB0ZXN0IGNvZGUuXCIsXG4gICAgW1JVTlRJTUVfRVJST1JTLnJlZ2VuZXJhdG9ySW5DbGllbnRGdW5jdGlvbkNvZGVdOiAgICAgICAgICAgICAgICAgICAgYHsjaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0gY29kZSwgYXJndW1lbnRzIG9yIGRlcGVuZGVuY2llcyBjYW5ub3QgY29udGFpbiBnZW5lcmF0b3JzIG9yIFwiYXN5bmMvYXdhaXRcIiBzeW50YXggKHVzZSBQcm9taXNlcyBpbnN0ZWFkKS5gLFxuICAgIFtSVU5USU1FX0VSUk9SUy5pbnZhbGlkQ2xpZW50RnVuY3Rpb25UZXN0UnVuQmluZGluZ106ICAgICAgICAgICAgICAgICdUaGUgXCJib3VuZFRlc3RSdW5cIiBvcHRpb24gdmFsdWUgaXMgZXhwZWN0ZWQgdG8gYmUgYSB0ZXN0IGNvbnRyb2xsZXIuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuaW52YWxpZFZhbHVlVHlwZV06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAne3NtdGhnfSBpcyBleHBlY3RlZCB0byBiZSBhIHt0eXBlfSwgYnV0IGl0IHdhcyB7YWN0dWFsfS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy51bnN1cHBvcnRlZFVybFByb3RvY29sXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgc3BlY2lmaWVkIFwie3VybH1cIiB0ZXN0IHBhZ2UgVVJMIHVzZXMgYW4gdW5zdXBwb3J0ZWQge3Byb3RvY29sfTovLyBwcm90b2NvbC4gT25seSByZWxhdGl2ZSBVUkxzIG9yIGFic29sdXRlIFVSTHMgd2l0aCBodHRwOi8vLCBodHRwczovLyBhbmQgZmlsZTovLyBwcm90b2NvbHMgYXJlIHN1cHBvcnRlZC4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy50ZXN0Q29udHJvbGxlclByb3h5Q2Fubm90UmVzb2x2ZVRlc3RSdW5dOiAgICAgICAgICAgIGBDYW5ub3QgaW1wbGljaXRseSByZXNvbHZlIHRoZSB0ZXN0IHJ1biBpbiB0aGUgY29udGV4dCBvZiB3aGljaCB0aGUgdGVzdCBjb250cm9sbGVyIGFjdGlvbiBzaG91bGQgYmUgZXhlY3V0ZWQuIFVzZSB0ZXN0IGZ1bmN0aW9uJ3MgJ3QnIGFyZ3VtZW50IGluc3RlYWQuYCxcbiAgICBbUlVOVElNRV9FUlJPUlMudGltZUxpbWl0ZWRQcm9taXNlVGltZW91dEV4cGlyZWRdOiAgICAgICAgICAgICAgICAgICAnVGltZW91dCBleHBpcmVkIGZvciBhIHRpbWUgbGltaXRlZCBwcm9taXNlJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90U2V0VmlkZW9PcHRpb25zV2l0aG91dEJhc2VWaWRlb1BhdGhTcGVjaWZpZWRdOiAnVW5hYmxlIHRvIHNldCB2aWRlbyBvciBlbmNvZGluZyBvcHRpb25zIHdoZW4gdmlkZW8gcmVjb3JkaW5nIGlzIGRpc2FibGVkLiBTcGVjaWZ5IHRoZSBiYXNlIHBhdGggd2hlcmUgdmlkZW8gZmlsZXMgYXJlIHN0b3JlZCB0byBlbmFibGUgcmVjb3JkaW5nLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLm11bHRpcGxlQVBJTWV0aG9kQ2FsbEZvcmJpZGRlbl06ICAgICAgICAgICAgICAgICAgICAgJ1lvdSBjYW5ub3QgY2FsbCB0aGUgXCJ7bWV0aG9kTmFtZX1cIiBtZXRob2QgbW9yZSB0aGFuIG9uY2UuIFBhc3MgYW4gYXJyYXkgb2YgcGFyYW1ldGVycyB0byB0aGlzIG1ldGhvZCBpbnN0ZWFkLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmludmFsaWRSZXBvcnRlck91dHB1dF06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJTcGVjaWZ5IGEgZmlsZSBuYW1lIG9yIGEgd3JpdGFibGUgc3RyZWFtIGFzIHRoZSByZXBvcnRlcidzIG91dHB1dCB0YXJnZXQuXCIsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdFJlYWRTU0xDZXJ0RmlsZV06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VuYWJsZSB0byByZWFkIHRoZSBcIntwYXRofVwiIGZpbGUsIHNwZWNpZmllZCBieSB0aGUgXCJ7b3B0aW9ufVwiIHNzbCBvcHRpb24uIEVycm9yIGRldGFpbHM6XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7ZXJyfScsXG5cbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90UHJlcGFyZVRlc3RzRHVlVG9FcnJvcl06ICdDYW5ub3QgcHJlcGFyZSB0ZXN0cyBkdWUgdG8gYW4gZXJyb3IuXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAne2Vyck1lc3NhZ2V9JyxcblxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RQYXJzZVJhd0ZpbGVdOiAnQ2Fubm90IHBhcnNlIGEgdGVzdCBzb3VyY2UgZmlsZSBpbiB0aGUgcmF3IGZvcm1hdCBhdCBcIntwYXRofVwiIGR1ZSB0byBhbiBlcnJvci5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAne2Vyck1lc3NhZ2V9JyxcblxuICAgIFtSVU5USU1FX0VSUk9SUy50ZXN0ZWRBcHBGYWlsZWRXaXRoRXJyb3JdOiAnVGVzdGVkIGFwcCBmYWlsZWQgd2l0aCBhbiBlcnJvcjpcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAne2Vyck1lc3NhZ2V9JyxcblxuICAgIFtSVU5USU1FX0VSUk9SUy51bmFibGVUb09wZW5Ccm93c2VyXTogJ1dhcyB1bmFibGUgdG8gb3BlbiB0aGUgYnJvd3NlciBcInthbGlhc31cIiBkdWUgdG8gZXJyb3IuXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAne2Vyck1lc3NhZ2V9JyxcblxuICAgIFtSVU5USU1FX0VSUk9SUy5yZXF1ZXN0SG9va0NvbmZpZ3VyZUFQSUVycm9yXTogJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBjb25maWd1cmluZyB0aGUgcmVxdWVzdCBob29rOlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3tyZXF1ZXN0SG9va05hbWV9OiB7ZXJyTXNnfScsXG5cbiAgICBbUlVOVElNRV9FUlJPUlMuZm9yYmlkZGVuQ2hhcmF0ZXJzSW5TY3JlZW5zaG90UGF0aF06ICdUaGVyZSBhcmUgZm9yYmlkZGVuIGNoYXJhY3RlcnMgaW4gdGhlIFwie3NjcmVlbnNob3RQYXRofVwiIHtzY3JlZW5zaG90UGF0aFR5cGV9OlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB7Zm9yYmlkZGVuQ2hhcnNEZXNjcmlwdGlvbn0nLFxuXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdEZpbmRGRk1QRUddOiAnVW5hYmxlIHRvIGxvY2F0ZSB0aGUgRkZtcGVnIGV4ZWN1dGFibGUgcmVxdWlyZWQgdG8gcmVjb3JkIHZpZGVvcy4gRG8gb25lIG9mIHRoZSBmb2xsb3dpbmc6XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKiBhZGQgdGhlIEZGbXBlZyBpbnN0YWxsYXRpb24gZGlyZWN0b3J5IHRvIHRoZSBQQVRIIGVudmlyb25tZW50IHZhcmlhYmxlLFxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyogc3BlY2lmeSB0aGUgcGF0aCB0byB0aGUgRkZtcGVnIGV4ZWN1dGFibGUgaW4gdGhlIEZGTVBFR19QQVRIIGVudmlyb25tZW50IHZhcmlhYmxlIG9yIHRoZSBmZm1wZWdQYXRoIHZpZGVvIG9wdGlvbixcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcqIGluc3RhbGwgdGhlIEBmZm1wZWctaW5zdGFsbGVyL2ZmbXBlZyBwYWNrYWdlIGZyb20gbnBtLicsXG5cbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90RmluZFR5cGVzY3JpcHRDb25maWd1cmF0aW9uRmlsZV06ICAgICAgICAgICAgICAnVW5hYmxlIHRvIGZpbmQgdGhlIFR5cGVTY3JpcHQgY29uZmlndXJhdGlvbiBmaWxlIGluIFwie2ZpbGVQYXRofVwiJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2xpZW50U2NyaXB0SW5pdGlhbGl6ZXJJc05vdFNwZWNpZmllZF06ICAgICAgICAgICAgICAnU3BlY2lmeSB0aGUgSmF2YVNjcmlwdCBmaWxlIHBhdGgsIG1vZHVsZSBuYW1lIG9yIHNjcmlwdCBjb250ZW50IHRvIGluamVjdCBhIGNsaWVudCBzY3JpcHQuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2xpZW50U2NyaXB0QmFzZVBhdGhJc05vdFNwZWNpZmllZF06ICAgICAgICAgICAgICAgICAnU3BlY2lmeSB0aGUgYmFzZSBwYXRoIGZvciB0aGUgY2xpZW50IHNjcmlwdCBmaWxlLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNsaWVudFNjcmlwdEluaXRpYWxpemVyTXVsdGlwbGVDb250ZW50U291cmNlc106ICAgICAgJ1lvdSBjYW5ub3QgY29tYmluZSB0aGUgZmlsZSBwYXRoLCBtb2R1bGUgbmFtZSBhbmQgc2NyaXB0IGNvbnRlbnQgd2hlbiB5b3Ugc3BlY2lmeSBhIGNsaWVudCBzY3JpcHQgdG8gaW5qZWN0LicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdExvYWRDbGllbnRTY3JpcHRGcm9tUGF0aF06ICAgICAgICAgICAgICAgICAgICAgJ0Nhbm5vdCBsb2FkIGEgY2xpZW50IHNjcmlwdCBmcm9tIHtwYXRofS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jbGllbnRTY3JpcHRNb2R1bGVFbnRyeVBvaW50UGF0aENhbGN1bGF0aW9uRXJyb3JdOiAgICdBbiBlcnJvciBvY2N1cnJlZCB3aGVuIHRyeWluZyB0byBsb2NhdGUgdGhlIGluamVjdGVkIGNsaWVudCBzY3JpcHQgbW9kdWxlOlxcblxcbntlcnJvck1lc3NhZ2V9LicsXG4gICAgW1JVTlRJTUVfRVJST1JTLm1ldGhvZElzTm90QXZhaWxhYmxlRm9yQW5JUENIb3N0XTogICAgICAgICAgICAgICAgICAgJ1RoaXMgbWV0aG9kIGNhbm5vdCBiZSBjYWxsZWQgb24gYSBzZXJ2aWNlIGhvc3QuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMudG9vTGFyZ2VJUENQYXlsb2FkXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHNwZWNpZmllZCBwYXlsb2FkIGlzIHRvbyBsYXJnZSB0byBmb3JtIGFuIElQQyBwYWNrZXQuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMubWFsZm9ybWVkSVBDTWVzc2FnZV06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IHByb2Nlc3MgYSBtYWxmb3JtZWQgSVBDIG1lc3NhZ2UuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMudW5leHBlY3RlZElQQ0hlYWRQYWNrZXRdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IGNyZWF0ZSBhbiBJUEMgbWVzc2FnZSBkdWUgdG8gYW4gdW5leHBlY3RlZCBJUEMgaGVhZCBwYWNrZXQuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMudW5leHBlY3RlZElQQ0JvZHlQYWNrZXRdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IGNyZWF0ZSBhbiBJUEMgbWVzc2FnZSBkdWUgdG8gYW4gdW5leHBlY3RlZCBJUEMgYm9keSBwYWNrZXQuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMudW5leHBlY3RlZElQQ1RhaWxQYWNrZXRdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IGNyZWF0ZSBhbiBJUEMgbWVzc2FnZSBkdWUgdG8gYW4gdW5leHBlY3RlZCBJUEMgdGFpbCBwYWNrZXQuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90VXNlQWxsb3dNdWx0aXBsZVdpbmRvd3NPcHRpb25Gb3JMZWdhY3lUZXN0c106ICAnWW91IGNhbm5vdCBydW4gTGVnYWN5IEFQSSB0ZXN0cyBpbiBtdWx0aS13aW5kb3cgbW9kZS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RVc2VBbGxvd011bHRpcGxlV2luZG93c09wdGlvbkZvclNvbWVCcm93c2Vyc106ICdZb3UgY2Fubm90IHVzZSBtdWx0aS13aW5kb3cgbW9kZSBpbiB7YnJvd3NlcnN9Lidcbn07XG4iXX0=