"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const callsite_record_1 = require("callsite-record");
const types_1 = require("../types");
const utils_1 = require("./utils");
const templates_1 = __importDefault(require("./templates"));
function getTestCafeErrorInCustomScriptError(err, viewportWidth) {
    const originErrTemplate = templates_1.default[err.originError.code];
    const originErrMessage = '\n' + err.originError.message;
    let originCallsiteMarkup = '';
    if (err.errCallsite && originErrTemplate && !utils_1.shouldSkipCallsite(err.originError)) {
        // HACK: we need to get callsite for custom TestCafe script without real file for it.
        // We use expression as a file content
        originCallsiteMarkup = err.errCallsite._renderRecord(err.expression, {
            renderer: callsite_record_1.renderers.html,
            stack: false
        });
    }
    const originErrorText = originErrTemplate ? originErrTemplate(err.originError, viewportWidth) : originErrMessage +
        '\n';
    return utils_1.markup(err, `
        An unhandled error occurred in the custom script:
        ${originErrorText}${!originCallsiteMarkup ? `\n${utils_1.formatExpressionMessage(err.expression, err.line, err.column)}` : ''}
    `, originCallsiteMarkup);
}
function renderErrorTemplate(err, viewportWidth) {
    if (err.code === types_1.TEST_RUN_ERRORS.uncaughtTestCafeErrorInCustomScript)
        return getTestCafeErrorInCustomScriptError(err, viewportWidth);
    return utils_1.markup(err, templates_1.default[err.code](err, viewportWidth));
}
exports.default = renderErrorTemplate;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVuZGVyLWVycm9yLXRlbXBsYXRlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2Vycm9ycy90ZXN0LXJ1bi9yZW5kZXItZXJyb3ItdGVtcGxhdGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxxREFBNEM7QUFDNUMsb0NBQTJDO0FBQzNDLG1DQUE4RTtBQUM5RSw0REFBb0M7QUFFcEMsU0FBUyxtQ0FBbUMsQ0FBRSxHQUFHLEVBQUUsYUFBYTtJQUM1RCxNQUFNLGlCQUFpQixHQUFJLG1CQUFTLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMzRCxNQUFNLGdCQUFnQixHQUFLLElBQUksR0FBRyxHQUFHLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQztJQUMxRCxJQUFJLG9CQUFvQixHQUFHLEVBQUUsQ0FBQztJQUU5QixJQUFJLEdBQUcsQ0FBQyxXQUFXLElBQUksaUJBQWlCLElBQUksQ0FBQywwQkFBa0IsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLEVBQUU7UUFDOUUscUZBQXFGO1FBQ3JGLHNDQUFzQztRQUN0QyxvQkFBb0IsR0FBRyxHQUFHLENBQUMsV0FBVyxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFO1lBQ2pFLFFBQVEsRUFBRSwyQkFBUyxDQUFDLElBQUk7WUFDeEIsS0FBSyxFQUFLLEtBQUs7U0FDbEIsQ0FBQyxDQUFDO0tBQ047SUFFRCxNQUFNLGVBQWUsR0FBRyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsZ0JBQWdCO1FBQ2hCLElBQUksQ0FBQztJQUVyRyxPQUFPLGNBQU0sQ0FBQyxHQUFHLEVBQUU7O1VBRWIsZUFBZSxHQUFHLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLEtBQUssK0JBQXVCLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBRSxHQUFHLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFO0tBQ3hILEVBQUUsb0JBQW9CLENBQUMsQ0FBQztBQUM3QixDQUFDO0FBRUQsU0FBd0IsbUJBQW1CLENBQUUsR0FBRyxFQUFFLGFBQWE7SUFDM0QsSUFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLHVCQUFlLENBQUMsbUNBQW1DO1FBQ2hFLE9BQU8sbUNBQW1DLENBQUMsR0FBRyxFQUFFLGFBQWEsQ0FBQyxDQUFDO0lBRW5FLE9BQU8sY0FBTSxDQUFDLEdBQUcsRUFBRSxtQkFBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsYUFBYSxDQUFDLENBQUMsQ0FBQztBQUNoRSxDQUFDO0FBTEQsc0NBS0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZW5kZXJlcnMgfSBmcm9tICdjYWxsc2l0ZS1yZWNvcmQnO1xuaW1wb3J0IHsgVEVTVF9SVU5fRVJST1JTIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgbWFya3VwLCBzaG91bGRTa2lwQ2FsbHNpdGUsIGZvcm1hdEV4cHJlc3Npb25NZXNzYWdlIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgVEVNUExBVEVTIGZyb20gJy4vdGVtcGxhdGVzJztcblxuZnVuY3Rpb24gZ2V0VGVzdENhZmVFcnJvckluQ3VzdG9tU2NyaXB0RXJyb3IgKGVyciwgdmlld3BvcnRXaWR0aCkge1xuICAgIGNvbnN0IG9yaWdpbkVyclRlbXBsYXRlICA9IFRFTVBMQVRFU1tlcnIub3JpZ2luRXJyb3IuY29kZV07XG4gICAgY29uc3Qgb3JpZ2luRXJyTWVzc2FnZSAgID0gJ1xcbicgKyBlcnIub3JpZ2luRXJyb3IubWVzc2FnZTtcbiAgICBsZXQgb3JpZ2luQ2FsbHNpdGVNYXJrdXAgPSAnJztcblxuICAgIGlmIChlcnIuZXJyQ2FsbHNpdGUgJiYgb3JpZ2luRXJyVGVtcGxhdGUgJiYgIXNob3VsZFNraXBDYWxsc2l0ZShlcnIub3JpZ2luRXJyb3IpKSB7XG4gICAgICAgIC8vIEhBQ0s6IHdlIG5lZWQgdG8gZ2V0IGNhbGxzaXRlIGZvciBjdXN0b20gVGVzdENhZmUgc2NyaXB0IHdpdGhvdXQgcmVhbCBmaWxlIGZvciBpdC5cbiAgICAgICAgLy8gV2UgdXNlIGV4cHJlc3Npb24gYXMgYSBmaWxlIGNvbnRlbnRcbiAgICAgICAgb3JpZ2luQ2FsbHNpdGVNYXJrdXAgPSBlcnIuZXJyQ2FsbHNpdGUuX3JlbmRlclJlY29yZChlcnIuZXhwcmVzc2lvbiwge1xuICAgICAgICAgICAgcmVuZGVyZXI6IHJlbmRlcmVycy5odG1sLFxuICAgICAgICAgICAgc3RhY2s6ICAgIGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IG9yaWdpbkVycm9yVGV4dCA9IG9yaWdpbkVyclRlbXBsYXRlID8gb3JpZ2luRXJyVGVtcGxhdGUoZXJyLm9yaWdpbkVycm9yLCB2aWV3cG9ydFdpZHRoKSA6IG9yaWdpbkVyck1lc3NhZ2UgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nO1xuXG4gICAgcmV0dXJuIG1hcmt1cChlcnIsIGBcbiAgICAgICAgQW4gdW5oYW5kbGVkIGVycm9yIG9jY3VycmVkIGluIHRoZSBjdXN0b20gc2NyaXB0OlxuICAgICAgICAke29yaWdpbkVycm9yVGV4dH0keyFvcmlnaW5DYWxsc2l0ZU1hcmt1cCA/IGBcXG4ke2Zvcm1hdEV4cHJlc3Npb25NZXNzYWdlKGVyci5leHByZXNzaW9uLCBlcnIubGluZSwgZXJyLmNvbHVtbil9YCA6ICcnfVxuICAgIGAsIG9yaWdpbkNhbGxzaXRlTWFya3VwKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVuZGVyRXJyb3JUZW1wbGF0ZSAoZXJyLCB2aWV3cG9ydFdpZHRoKSB7XG4gICAgaWYgKGVyci5jb2RlID09PSBURVNUX1JVTl9FUlJPUlMudW5jYXVnaHRUZXN0Q2FmZUVycm9ySW5DdXN0b21TY3JpcHQpXG4gICAgICAgIHJldHVybiBnZXRUZXN0Q2FmZUVycm9ySW5DdXN0b21TY3JpcHRFcnJvcihlcnIsIHZpZXdwb3J0V2lkdGgpO1xuXG4gICAgcmV0dXJuIG1hcmt1cChlcnIsIFRFTVBMQVRFU1tlcnIuY29kZV0oZXJyLCB2aWV3cG9ydFdpZHRoKSk7XG59XG5cbiJdfQ==