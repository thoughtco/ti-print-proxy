"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const load_babel_libs_1 = __importDefault(require("../../../load-babel-libs"));
const api_based_1 = __importDefault(require("../../api-based"));
const BABEL_RUNTIME_RE = /^babel-runtime(\\|\/|$)/;
const FLOW_MARKER_RE = /^\s*\/\/\s*@flow\s*\n|^\s*\/\*\s*@flow\s*\*\//;
class ESNextTestFileCompiler extends api_based_1.default {
    static getBabelOptions(filename, code) {
        const { presetStage2, presetFlow, transformRuntime, transformClassProperties, presetEnv, presetReact } = load_babel_libs_1.default();
        // NOTE: passPrePreset and complex presets is a workaround for https://github.com/babel/babel/issues/2877
        // Fixes https://github.com/DevExpress/testcafe/issues/969
        return {
            passPerPreset: true,
            presets: [
                {
                    passPerPreset: false,
                    presets: [{ plugins: [transformRuntime] }, presetStage2, presetEnv, presetReact]
                },
                FLOW_MARKER_RE.test(code) ? {
                    passPerPreset: false,
                    presets: [{ plugins: [transformClassProperties] }, presetFlow]
                } : {}
            ],
            filename: filename,
            retainLines: true,
            sourceMaps: 'inline',
            ast: false,
            babelrc: false,
            highlightCode: false,
            resolveModuleSource: source => {
                if (source === 'testcafe')
                    return api_based_1.default.EXPORTABLE_LIB_PATH;
                if (BABEL_RUNTIME_RE.test(source)) {
                    try {
                        return require.resolve(source);
                    }
                    catch (err) {
                        return source;
                    }
                }
                return source;
            }
        };
    }
    _compileCode(code, filename) {
        const { babel } = load_babel_libs_1.default();
        if (this.cache[filename])
            return this.cache[filename];
        const opts = ESNextTestFileCompiler.getBabelOptions(filename, code);
        const compiled = babel.transform(code, opts);
        this.cache[filename] = compiled.code;
        return compiled.code;
    }
    _getRequireCompilers() {
        return {
            '.js': (code, filename) => this._compileCode(code, filename),
            '.jsx': (code, filename) => this._compileCode(code, filename),
        };
    }
    getSupportedExtension() {
        return ['.js', '.jsx'];
    }
}
exports.default = ESNextTestFileCompiler;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvY29tcGlsZXIvdGVzdC1maWxlL2Zvcm1hdHMvZXMtbmV4dC9jb21waWxlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLCtFQUFxRDtBQUNyRCxnRUFBMkQ7QUFFM0QsTUFBTSxnQkFBZ0IsR0FBRyx5QkFBeUIsQ0FBQztBQUNuRCxNQUFNLGNBQWMsR0FBSywrQ0FBK0MsQ0FBQztBQUV6RSxNQUFxQixzQkFBdUIsU0FBUSxtQkFBNEI7SUFDNUUsTUFBTSxDQUFDLGVBQWUsQ0FBRSxRQUFRLEVBQUUsSUFBSTtRQUNsQyxNQUFNLEVBQUUsWUFBWSxFQUFFLFVBQVUsRUFBRSxnQkFBZ0IsRUFBRSx3QkFBd0IsRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLEdBQUcseUJBQWEsRUFBRSxDQUFDO1FBRXpILHlHQUF5RztRQUN6RywwREFBMEQ7UUFDMUQsT0FBTztZQUNILGFBQWEsRUFBRSxJQUFJO1lBQ25CLE9BQU8sRUFBUTtnQkFDWDtvQkFDSSxhQUFhLEVBQUUsS0FBSztvQkFDcEIsT0FBTyxFQUFRLENBQUMsRUFBRSxPQUFPLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxXQUFXLENBQUM7aUJBQ3pGO2dCQUNELGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUN4QixhQUFhLEVBQUUsS0FBSztvQkFDcEIsT0FBTyxFQUFRLENBQUMsRUFBRSxPQUFPLEVBQUUsQ0FBQyx3QkFBd0IsQ0FBQyxFQUFFLEVBQUUsVUFBVSxDQUFDO2lCQUN2RSxDQUFDLENBQUMsQ0FBQyxFQUFFO2FBQ1Q7WUFDRCxRQUFRLEVBQU8sUUFBUTtZQUN2QixXQUFXLEVBQUksSUFBSTtZQUNuQixVQUFVLEVBQUssUUFBUTtZQUN2QixHQUFHLEVBQVksS0FBSztZQUNwQixPQUFPLEVBQVEsS0FBSztZQUNwQixhQUFhLEVBQUUsS0FBSztZQUVwQixtQkFBbUIsRUFBRSxNQUFNLENBQUMsRUFBRTtnQkFDMUIsSUFBSSxNQUFNLEtBQUssVUFBVTtvQkFDckIsT0FBTyxtQkFBNEIsQ0FBQyxtQkFBbUIsQ0FBQztnQkFFNUQsSUFBSSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUU7b0JBQy9CLElBQUk7d0JBQ0EsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO3FCQUNsQztvQkFDRCxPQUFPLEdBQUcsRUFBRTt3QkFDUixPQUFPLE1BQU0sQ0FBQztxQkFDakI7aUJBQ0o7Z0JBRUQsT0FBTyxNQUFNLENBQUM7WUFDbEIsQ0FBQztTQUNKLENBQUM7SUFDTixDQUFDO0lBRUQsWUFBWSxDQUFFLElBQUksRUFBRSxRQUFRO1FBQ3hCLE1BQU0sRUFBRSxLQUFLLEVBQUUsR0FBRyx5QkFBYSxFQUFFLENBQUM7UUFFbEMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQztZQUNwQixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFaEMsTUFBTSxJQUFJLEdBQU8sc0JBQXNCLENBQUMsZUFBZSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUN4RSxNQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztRQUU3QyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUM7UUFFckMsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDO0lBQ3pCLENBQUM7SUFFRCxvQkFBb0I7UUFDaEIsT0FBTztZQUNILEtBQUssRUFBRyxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQztZQUM3RCxNQUFNLEVBQUUsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxRQUFRLENBQUM7U0FDaEUsQ0FBQztJQUNOLENBQUM7SUFFRCxxQkFBcUI7UUFDakIsT0FBTyxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQztJQUMzQixDQUFDO0NBQ0o7QUFuRUQseUNBbUVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGxvYWRCYWJlbExpYnMgZnJvbSAnLi4vLi4vLi4vbG9hZC1iYWJlbC1saWJzJztcbmltcG9ydCBBUElCYXNlZFRlc3RGaWxlQ29tcGlsZXJCYXNlIGZyb20gJy4uLy4uL2FwaS1iYXNlZCc7XG5cbmNvbnN0IEJBQkVMX1JVTlRJTUVfUkUgPSAvXmJhYmVsLXJ1bnRpbWUoXFxcXHxcXC98JCkvO1xuY29uc3QgRkxPV19NQVJLRVJfUkUgICA9IC9eXFxzKlxcL1xcL1xccypAZmxvd1xccypcXG58XlxccypcXC9cXCpcXHMqQGZsb3dcXHMqXFwqXFwvLztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRVNOZXh0VGVzdEZpbGVDb21waWxlciBleHRlbmRzIEFQSUJhc2VkVGVzdEZpbGVDb21waWxlckJhc2Uge1xuICAgIHN0YXRpYyBnZXRCYWJlbE9wdGlvbnMgKGZpbGVuYW1lLCBjb2RlKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlc2V0U3RhZ2UyLCBwcmVzZXRGbG93LCB0cmFuc2Zvcm1SdW50aW1lLCB0cmFuc2Zvcm1DbGFzc1Byb3BlcnRpZXMsIHByZXNldEVudiwgcHJlc2V0UmVhY3QgfSA9IGxvYWRCYWJlbExpYnMoKTtcblxuICAgICAgICAvLyBOT1RFOiBwYXNzUHJlUHJlc2V0IGFuZCBjb21wbGV4IHByZXNldHMgaXMgYSB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vYmFiZWwvYmFiZWwvaXNzdWVzLzI4NzdcbiAgICAgICAgLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL0RldkV4cHJlc3MvdGVzdGNhZmUvaXNzdWVzLzk2OVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFzc1BlclByZXNldDogdHJ1ZSxcbiAgICAgICAgICAgIHByZXNldHM6ICAgICAgIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBhc3NQZXJQcmVzZXQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBwcmVzZXRzOiAgICAgICBbeyBwbHVnaW5zOiBbdHJhbnNmb3JtUnVudGltZV0gfSwgcHJlc2V0U3RhZ2UyLCBwcmVzZXRFbnYsIHByZXNldFJlYWN0XVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgRkxPV19NQVJLRVJfUkUudGVzdChjb2RlKSA/IHtcbiAgICAgICAgICAgICAgICAgICAgcGFzc1BlclByZXNldDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHByZXNldHM6ICAgICAgIFt7IHBsdWdpbnM6IFt0cmFuc2Zvcm1DbGFzc1Byb3BlcnRpZXNdIH0sIHByZXNldEZsb3ddXG4gICAgICAgICAgICAgICAgfSA6IHt9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZmlsZW5hbWU6ICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgICByZXRhaW5MaW5lczogICB0cnVlLFxuICAgICAgICAgICAgc291cmNlTWFwczogICAgJ2lubGluZScsXG4gICAgICAgICAgICBhc3Q6ICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGJhYmVscmM6ICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgaGlnaGxpZ2h0Q29kZTogZmFsc2UsXG5cbiAgICAgICAgICAgIHJlc29sdmVNb2R1bGVTb3VyY2U6IHNvdXJjZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZSA9PT0gJ3Rlc3RjYWZlJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFQSUJhc2VkVGVzdEZpbGVDb21waWxlckJhc2UuRVhQT1JUQUJMRV9MSUJfUEFUSDtcblxuICAgICAgICAgICAgICAgIGlmIChCQUJFTF9SVU5USU1FX1JFLnRlc3Qoc291cmNlKSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVpcmUucmVzb2x2ZShzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIF9jb21waWxlQ29kZSAoY29kZSwgZmlsZW5hbWUpIHtcbiAgICAgICAgY29uc3QgeyBiYWJlbCB9ID0gbG9hZEJhYmVsTGlicygpO1xuXG4gICAgICAgIGlmICh0aGlzLmNhY2hlW2ZpbGVuYW1lXSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlW2ZpbGVuYW1lXTtcblxuICAgICAgICBjb25zdCBvcHRzICAgICA9IEVTTmV4dFRlc3RGaWxlQ29tcGlsZXIuZ2V0QmFiZWxPcHRpb25zKGZpbGVuYW1lLCBjb2RlKTtcbiAgICAgICAgY29uc3QgY29tcGlsZWQgPSBiYWJlbC50cmFuc2Zvcm0oY29kZSwgb3B0cyk7XG5cbiAgICAgICAgdGhpcy5jYWNoZVtmaWxlbmFtZV0gPSBjb21waWxlZC5jb2RlO1xuXG4gICAgICAgIHJldHVybiBjb21waWxlZC5jb2RlO1xuICAgIH1cblxuICAgIF9nZXRSZXF1aXJlQ29tcGlsZXJzICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICcuanMnOiAgKGNvZGUsIGZpbGVuYW1lKSA9PiB0aGlzLl9jb21waWxlQ29kZShjb2RlLCBmaWxlbmFtZSksXG4gICAgICAgICAgICAnLmpzeCc6IChjb2RlLCBmaWxlbmFtZSkgPT4gdGhpcy5fY29tcGlsZUNvZGUoY29kZSwgZmlsZW5hbWUpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGdldFN1cHBvcnRlZEV4dGVuc2lvbiAoKSB7XG4gICAgICAgIHJldHVybiBbJy5qcycsICcuanN4J107XG4gICAgfVxufVxuIl19