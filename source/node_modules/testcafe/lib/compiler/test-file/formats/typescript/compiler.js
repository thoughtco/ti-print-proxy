"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const lodash_1 = require("lodash");
const os_family_1 = __importDefault(require("os-family"));
const api_based_1 = __importDefault(require("../../api-based"));
const compiler_1 = __importDefault(require("../es-next/compiler"));
const typescript_configuration_1 = __importDefault(require("../../../../configuration/typescript-configuration"));
const RENAMED_DEPENDENCIES_MAP = new Map([['testcafe', api_based_1.default.EXPORTABLE_LIB_PATH]]);
class TypeScriptTestFileCompiler extends api_based_1.default {
    constructor(compilerOptions = {}) {
        super();
        const tsConfigPath = compilerOptions.typeScriptOptions ? compilerOptions.typeScriptOptions.tsConfigPath : null;
        this.tsConfig = new typescript_configuration_1.default(tsConfigPath);
    }
    static _normalizeFilename(filename) {
        filename = path_1.default.resolve(filename);
        if (os_family_1.default.win)
            filename = filename.toLowerCase();
        return filename;
    }
    static _getTSDefsPath() {
        return TypeScriptTestFileCompiler._normalizeFilename(path_1.default.resolve(__dirname, '../../../../../ts-defs/index.d.ts'));
    }
    static _reportErrors(diagnostics) {
        // NOTE: lazy load the compiler
        const ts = require('typescript');
        let errMsg = 'TypeScript compilation failed.\n';
        diagnostics.forEach(d => {
            const message = ts.flattenDiagnosticMessageText(d.messageText, '\n');
            const file = d.file;
            if (file && d.start !== void 0) {
                const { line, character } = file.getLineAndCharacterOfPosition(d.start);
                errMsg += `${file.fileName} (${line + 1}, ${character + 1}): `;
            }
            errMsg += `${message}\n`;
        });
        throw new Error(errMsg);
    }
    _compileCodeForTestFiles(testFilesInfo) {
        return this.tsConfig.init()
            .then(() => {
            return super._compileCodeForTestFiles(testFilesInfo);
        });
    }
    _compileFilesToCache(ts, filenames) {
        const opts = this.tsConfig.getOptions();
        const program = ts.createProgram([TypeScriptTestFileCompiler.tsDefsPath, ...filenames], opts);
        program.getSourceFiles().forEach(sourceFile => {
            // @ts-ignore A hack to allow import globally installed TestCafe in tests
            sourceFile.renamedDependencies = RENAMED_DEPENDENCIES_MAP;
        });
        const diagnostics = ts.getPreEmitDiagnostics(program);
        if (diagnostics.length)
            TypeScriptTestFileCompiler._reportErrors(diagnostics);
        // NOTE: The first argument of emit() is a source file to be compiled. If it's undefined, all files in
        // <program> will be compiled. <program> contains a file specified in createProgram() plus all its dependencies.
        // This mode is much faster than compiling files one-by-one, and it is used in the tsc CLI compiler.
        program.emit(void 0, (outputName, result, writeBOM, onError, sources) => {
            if (!sources)
                return;
            const sourcePath = TypeScriptTestFileCompiler._normalizeFilename(sources[0].fileName);
            this.cache[sourcePath] = result;
        });
    }
    _precompileCode(testFilesInfo) {
        // NOTE: lazy load the compiler
        const ts = require('typescript');
        const filenames = testFilesInfo.map(({ filename }) => filename);
        const normalizedFilenames = filenames.map(filename => TypeScriptTestFileCompiler._normalizeFilename(filename));
        const normalizedFilenamesMap = lodash_1.zipObject(normalizedFilenames, filenames);
        const uncachedFiles = normalizedFilenames
            .filter(filename => filename !== TypeScriptTestFileCompiler.tsDefsPath && !this.cache[filename])
            .map(filename => normalizedFilenamesMap[filename]);
        if (uncachedFiles.length)
            this._compileFilesToCache(ts, uncachedFiles);
        return normalizedFilenames.map(filename => this.cache[filename]);
    }
    _getRequireCompilers() {
        return {
            '.ts': (code, filename) => this._compileCode(code, filename),
            '.tsx': (code, filename) => this._compileCode(code, filename),
            '.js': (code, filename) => compiler_1.default.prototype._compileCode.call(this, code, filename),
            '.jsx': (code, filename) => compiler_1.default.prototype._compileCode.call(this, code, filename)
        };
    }
    get canPrecompile() {
        return true;
    }
    getSupportedExtension() {
        return ['.ts', '.tsx'];
    }
}
exports.default = TypeScriptTestFileCompiler;
TypeScriptTestFileCompiler.tsDefsPath = TypeScriptTestFileCompiler._getTSDefsPath();
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvY29tcGlsZXIvdGVzdC1maWxlL2Zvcm1hdHMvdHlwZXNjcmlwdC9jb21waWxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGdEQUF3QjtBQUN4QixtQ0FBbUM7QUFDbkMsMERBQTJCO0FBQzNCLGdFQUEyRDtBQUMzRCxtRUFBeUQ7QUFDekQsa0hBQXlGO0FBMkJ6RixNQUFNLHdCQUF3QixHQUFHLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUUsbUJBQTRCLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFFM0csTUFBcUIsMEJBQTJCLFNBQVEsbUJBQTRCO0lBS2hGLFlBQW9CLGtCQUFtQyxFQUFFO1FBQ3JELEtBQUssRUFBRSxDQUFDO1FBRVIsTUFBTSxZQUFZLEdBQUcsZUFBZSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxlQUFlLENBQUMsaUJBQWlCLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7UUFFL0csSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGtDQUF1QixDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQzlELENBQUM7SUFFTyxNQUFNLENBQUMsa0JBQWtCLENBQUUsUUFBZ0I7UUFDL0MsUUFBUSxHQUFHLGNBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFbEMsSUFBSSxtQkFBRSxDQUFDLEdBQUc7WUFDTixRQUFRLEdBQUcsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBRXRDLE9BQU8sUUFBUSxDQUFDO0lBQ3BCLENBQUM7SUFFTyxNQUFNLENBQUMsY0FBYztRQUN6QixPQUFPLDBCQUEwQixDQUFDLGtCQUFrQixDQUFDLGNBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLG1DQUFtQyxDQUFDLENBQUMsQ0FBQztJQUN2SCxDQUFDO0lBRU8sTUFBTSxDQUFD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QUFZLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsUUFBUSxDQUFDO1NBQ3ZHLENBQUM7SUFDTixDQUFDO0lBRUQsSUFBVyxhQUFhO1FBQ3BCLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFTSxxQkFBcUI7UUFDeEIsT0FBTyxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQztJQUMzQixDQUFDOztBQWxITCw2Q0FtSEM7QUFsSGtCLHFDQUFVLEdBQUcsMEJBQTBCLENBQUMsY0FBYyxFQUFFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IHppcE9iamVjdCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgT1MgZnJvbSAnb3MtZmFtaWx5JztcbmltcG9ydCBBUElCYXNlZFRlc3RGaWxlQ29tcGlsZXJCYXNlIGZyb20gJy4uLy4uL2FwaS1iYXNlZCc7XG5pbXBvcnQgRVNOZXh0VGVzdEZpbGVDb21waWxlciBmcm9tICcuLi9lcy1uZXh0L2NvbXBpbGVyJztcbmltcG9ydCBUeXBlc2NyaXB0Q29uZmlndXJhdGlvbiBmcm9tICcuLi8uLi8uLi8uLi9jb25maWd1cmF0aW9uL3R5cGVzY3JpcHQtY29uZmlndXJhdGlvbic7XG5cbi8vIE5PVEU6IEZvciB0eXBlIGRlZmluaXRpb25zIG9ubHlcbmltcG9ydCBUeXBlU2NyaXB0LCB7IENvbXBpbGVyT3B0aW9uc1ZhbHVlIH0gZnJvbSAndHlwZXNjcmlwdCc7XG5pbXBvcnQgeyBEaWN0aW9uYXJ5IH0gZnJvbSAnLi4vLi4vLi4vLi4vY29uZmlndXJhdGlvbi9pbnRlcmZhY2VzJztcblxuXG5kZWNsYXJlIHR5cGUgVHlwZVNjcmlwdEluc3RhbmNlID0gdHlwZW9mIFR5cGVTY3JpcHQ7XG5cbmludGVyZmFjZSBDb21waWxlck9wdGlvbnMge1xuICAgIHR5cGVTY3JpcHRPcHRpb25zPzoge1xuICAgICAgICB0c0NvbmZpZ1BhdGg6IHN0cmluZztcbiAgICB9O1xufVxuXG5pbnRlcmZhY2UgVGVzdEZpbGVJbmZvIHtcbiAgICBmaWxlbmFtZTogc3RyaW5nO1xufVxuXG5kZWNsYXJlIGludGVyZmFjZSBSZXF1aXJlQ29tcGlsZXJGdW5jdGlvbiB7XG4gICAgKGNvZGU6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZyk6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFJlcXVpcmVDb21waWxlcnMge1xuICAgIFtleHRlbnNpb246IHN0cmluZ106IFJlcXVpcmVDb21waWxlckZ1bmN0aW9uO1xufVxuXG5jb25zdCBSRU5BTUVEX0RFUEVOREVOQ0lFU19NQVAgPSBuZXcgTWFwKFtbJ3Rlc3RjYWZlJywgQVBJQmFzZWRUZXN0RmlsZUNvbXBpbGVyQmFzZS5FWFBPUlRBQkxFX0xJQl9QQVRIXV0pO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUeXBlU2NyaXB0VGVzdEZpbGVDb21waWxlciBleHRlbmRzIEFQSUJhc2VkVGVzdEZpbGVDb21waWxlckJhc2Uge1xuICAgIHByaXZhdGUgc3RhdGljIHRzRGVmc1BhdGggPSBUeXBlU2NyaXB0VGVzdEZpbGVDb21waWxlci5fZ2V0VFNEZWZzUGF0aCgpO1xuXG4gICAgcHJpdmF0ZSB0c0NvbmZpZzogVHlwZXNjcmlwdENvbmZpZ3VyYXRpb247XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IgKGNvbXBpbGVyT3B0aW9uczogQ29tcGlsZXJPcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICBjb25zdCB0c0NvbmZpZ1BhdGggPSBjb21waWxlck9wdGlvbnMudHlwZVNjcmlwdE9wdGlvbnMgPyBjb21waWxlck9wdGlvbnMudHlwZVNjcmlwdE9wdGlvbnMudHNDb25maWdQYXRoIDogbnVsbDtcblxuICAgICAgICB0aGlzLnRzQ29uZmlnID0gbmV3IFR5cGVzY3JpcHRDb25maWd1cmF0aW9uKHRzQ29uZmlnUGF0aCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgX25vcm1hbGl6ZUZpbGVuYW1lIChmaWxlbmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgZmlsZW5hbWUgPSBwYXRoLnJlc29sdmUoZmlsZW5hbWUpO1xuXG4gICAgICAgIGlmIChPUy53aW4pXG4gICAgICAgICAgICBmaWxlbmFtZSA9IGZpbGVuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgcmV0dXJuIGZpbGVuYW1lO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIF9nZXRUU0RlZnNQYXRoICgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gVHlwZVNjcmlwdFRlc3RGaWxlQ29tcGlsZXIuX25vcm1hbGl6ZUZpbGVuYW1lKHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuLi8uLi8uLi8uLi8uLi90cy1kZWZzL2luZGV4LmQudHMnKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgX3JlcG9ydEVycm9ycyAoZGlhZ25vc3RpY3M6IFJlYWRvbmx5PFR5cGVTY3JpcHQuRGlhZ25vc3RpY1tdPik6IHZvaWQge1xuICAgICAgICAvLyBOT1RFOiBsYXp5IGxvYWQgdGhlIGNvbXBpbGVyXG4gICAgICAgIGNvbnN0IHRzOiBUeXBlU2NyaXB0SW5zdGFuY2UgPSByZXF1aXJlKCd0eXBlc2NyaXB0Jyk7XG4gICAgICAgIGxldCBlcnJNc2cgPSAnVHlwZVNjcmlwdCBjb21waWxhdGlvbiBmYWlsZWQuXFxuJztcblxuICAgICAgICBkaWFnbm9zdGljcy5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRzLmZsYXR0ZW5EaWFnbm9zdGljTWVzc2FnZVRleHQoZC5tZXNzYWdlVGV4dCwgJ1xcbicpO1xuICAgICAgICAgICAgY29uc3QgZmlsZSAgICA9IGQuZmlsZTtcblxuICAgICAgICAgICAgaWYgKGZpbGUgJiYgZC5zdGFydCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBsaW5lLCBjaGFyYWN0ZXIgfSA9IGZpbGUuZ2V0TGluZUFuZENoYXJhY3Rlck9mUG9zaXRpb24oZC5zdGFydCk7XG5cbiAgICAgICAgICAgICAgICBlcnJNc2cgKz0gYCR7ZmlsZS5maWxlTmFtZX0gKCR7bGluZSArIDF9LCAke2NoYXJhY3RlciArIDF9KTogYDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyTXNnICs9IGAke21lc3NhZ2V9XFxuYDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgfVxuXG4gICAgcHVibGljIF9jb21waWxlQ29kZUZvclRlc3RGaWxlcyAodGVzdEZpbGVzSW5mbzogVGVzdEZpbGVJbmZvW10pOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRzQ29uZmlnLmluaXQoKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdXBlci5fY29tcGlsZUNvZGVGb3JUZXN0RmlsZXModGVzdEZpbGVzSW5mbyk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9jb21waWxlRmlsZXNUb0NhY2hlICh0czogVHlwZVNjcmlwdEluc3RhbmNlLCBmaWxlbmFtZXM6IHN0cmluZ1tdKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG9wdHMgICAgPSB0aGlzLnRzQ29uZmlnLmdldE9wdGlvbnMoKSBhcyBEaWN0aW9uYXJ5PENvbXBpbGVyT3B0aW9uc1ZhbHVlPjtcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IHRzLmNyZWF0ZVByb2dyYW0oW1R5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyLnRzRGVmc1BhdGgsIC4uLmZpbGVuYW1lc10sIG9wdHMpO1xuXG4gICAgICAgIHByb2dyYW0uZ2V0U291cmNlRmlsZXMoKS5mb3JFYWNoKHNvdXJjZUZpbGUgPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBBIGhhY2sgdG8gYWxsb3cgaW1wb3J0IGdsb2JhbGx5IGluc3RhbGxlZCBUZXN0Q2FmZSBpbiB0ZXN0c1xuICAgICAgICAgICAgc291cmNlRmlsZS5yZW5hbWVkRGVwZW5kZW5jaWVzID0gUkVOQU1FRF9ERVBFTkRFTkNJRVNfTUFQO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBkaWFnbm9zdGljcyA9IHRzLmdldFByZUVtaXREaWFnbm9zdGljcyhwcm9ncmFtKTtcblxuICAgICAgICBpZiAoZGlhZ25vc3RpY3MubGVuZ3RoKVxuICAgICAgICAgICAgVHlwZVNjcmlwdFRlc3RGaWxlQ29tcGlsZXIuX3JlcG9ydEVycm9ycyhkaWFnbm9zdGljcyk7XG5cbiAgICAgICAgLy8gTk9URTogVGhlIGZpcnN0IGFyZ3VtZW50IG9mIGVtaXQoKSBpcyBhIHNvdXJjZSBmaWxlIHRvIGJlIGNvbXBpbGVkLiBJZiBpdCdzIHVuZGVmaW5lZCwgYWxsIGZpbGVzIGluXG4gICAgICAgIC8vIDxwcm9ncmFtPiB3aWxsIGJlIGNvbXBpbGVkLiA8cHJvZ3JhbT4gY29udGFpbnMgYSBmaWxlIHNwZWNpZmllZCBpbiBjcmVhdGVQcm9ncmFtKCkgcGx1cyBhbGwgaXRzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgLy8gVGhpcyBtb2RlIGlzIG11Y2ggZmFzdGVyIHRoYW4gY29tcGlsaW5nIGZpbGVzIG9uZS1ieS1vbmUsIGFuZCBpdCBpcyB1c2VkIGluIHRoZSB0c2MgQ0xJIGNvbXBpbGVyLlxuICAgICAgICBwcm9ncmFtLmVtaXQodm9pZCAwLCAob3V0cHV0TmFtZSwgcmVzdWx0LCB3cml0ZUJPTSwgb25FcnJvciwgc291cmNlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2VzKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgY29uc3Qgc291cmNlUGF0aCA9IFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyLl9ub3JtYWxpemVGaWxlbmFtZShzb3VyY2VzWzBdLmZpbGVOYW1lKTtcblxuICAgICAgICAgICAgdGhpcy5jYWNoZVtzb3VyY2VQYXRoXSA9IHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIF9wcmVjb21waWxlQ29kZSAodGVzdEZpbGVzSW5mbzogVGVzdEZpbGVJbmZvW10pOiBzdHJpbmdbXSB7XG4gICAgICAgIC8vIE5PVEU6IGxhenkgbG9hZCB0aGUgY29tcGlsZXJcbiAgICAgICAgY29uc3QgdHM6IFR5cGVTY3JpcHRJbnN0YW5jZSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQnKTtcblxuICAgICAgICBjb25zdCBmaWxlbmFtZXMgICAgICAgICAgICAgID0gdGVzdEZpbGVzSW5mby5tYXAoKHsgZmlsZW5hbWUgfSkgPT4gZmlsZW5hbWUpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkRmlsZW5hbWVzICAgID0gZmlsZW5hbWVzLm1hcChmaWxlbmFtZSA9PiBUeXBlU2NyaXB0VGVzdEZpbGVDb21waWxlci5fbm9ybWFsaXplRmlsZW5hbWUoZmlsZW5hbWUpKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEZpbGVuYW1lc01hcCA9IHppcE9iamVjdChub3JtYWxpemVkRmlsZW5hbWVzLCBmaWxlbmFtZXMpO1xuXG4gICAgICAgIGNvbnN0IHVuY2FjaGVkRmlsZXMgPSBub3JtYWxpemVkRmlsZW5hbWVzXG4gICAgICAgICAgICAuZmlsdGVyKGZpbGVuYW1lID0+IGZpbGVuYW1lICE9PSBUeXBlU2NyaXB0VGVzdEZpbGVDb21waWxlci50c0RlZnNQYXRoICYmICF0aGlzLmNhY2hlW2ZpbGVuYW1lXSlcbiAgICAgICAgICAgIC5tYXAoZmlsZW5hbWUgPT4gbm9ybWFsaXplZEZpbGVuYW1lc01hcFtmaWxlbmFtZV0pO1xuXG4gICAgICAgIGlmICh1bmNhY2hlZEZpbGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVGaWxlc1RvQ2FjaGUodHMsIHVuY2FjaGVkRmlsZXMpO1xuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkRmlsZW5hbWVzLm1hcChmaWxlbmFtZSA9PiB0aGlzLmNhY2hlW2ZpbGVuYW1lXSk7XG4gICAgfVxuXG4gICAgcHVibGljIF9nZXRSZXF1aXJlQ29tcGlsZXJzICgpOiBSZXF1aXJlQ29tcGlsZXJzIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICcudHMnOiAgKGNvZGUsIGZpbGVuYW1lKSA9PiB0aGlzLl9jb21waWxlQ29kZShjb2RlLCBmaWxlbmFtZSksXG4gICAgICAgICAgICAnLnRzeCc6IChjb2RlLCBmaWxlbmFtZSkgPT4gdGhpcy5fY29tcGlsZUNvZGUoY29kZSwgZmlsZW5hbWUpLFxuICAgICAgICAgICAgJy5qcyc6ICAoY29kZSwgZmlsZW5hbWUpID0+IEVTTmV4dFRlc3RGaWxlQ29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlQ29kZS5jYWxsKHRoaXMsIGNvZGUsIGZpbGVuYW1lKSxcbiAgICAgICAgICAgICcuanN4JzogKGNvZGUsIGZpbGVuYW1lKSA9PiBFU05leHRUZXN0RmlsZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZUNvZGUuY2FsbCh0aGlzLCBjb2RlLCBmaWxlbmFtZSlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGNhblByZWNvbXBpbGUgKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0U3VwcG9ydGVkRXh0ZW5zaW9uICgpOiBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiBbJy50cycsICcudHN4J107XG4gICAgfVxufVxuIl19