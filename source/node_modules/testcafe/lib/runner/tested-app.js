"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const path_1 = require("path");
const tree_kill_1 = __importDefault(require("tree-kill"));
const os_family_1 = __importDefault(require("os-family"));
const delay_1 = __importDefault(require("../utils/delay"));
const runtime_1 = require("../errors/runtime");
const types_1 = require("../errors/types");
const resolve_path_relatively_cwd_1 = __importDefault(require("../utils/resolve-path-relatively-cwd"));
const MODULES_BIN_DIR = resolve_path_relatively_cwd_1.default('./node_modules/.bin');
const ENV_PATH_KEY = (function () {
    if (os_family_1.default.win) {
        let pathKey = 'Path';
        Object.keys(process.env).forEach(key => {
            if (key.toLowerCase() === 'path')
                pathKey = key;
        });
        return pathKey;
    }
    return 'PATH';
})();
class TestedApp {
    constructor() {
        this._process = null;
        this.errorPromise = null;
        this._killed = false;
    }
    async start(command, initDelay) {
        this.errorPromise = new Promise((resolve, reject) => {
            const env = Object.assign({}, process.env);
            const path = env[ENV_PATH_KEY] || '';
            const pathParts = path.split(path_1.delimiter);
            pathParts.unshift(MODULES_BIN_DIR);
            env[ENV_PATH_KEY] = pathParts.join(path_1.delimiter);
            this._process = child_process_1.exec(command, { env }, err => {
                if (!this._killed && err) {
                    const message = err.stack || String(err);
                    reject(new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.testedAppFailedWithError, message));
                }
            });
        });
        await Promise.race([
            delay_1.default(initDelay),
            this.errorPromise
        ]);
    }
    async kill() {
        this._killed = true;
        const killPromise = new Promise(resolve => tree_kill_1.default(this._process.pid, 'SIGTERM', resolve));
        await killPromise;
    }
}
exports.default = TestedApp;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdGVkLWFwcC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ydW5uZXIvdGVzdGVkLWFwcC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGlEQUFtRDtBQUNuRCwrQkFBa0Q7QUFDbEQsMERBQTZCO0FBQzdCLDBEQUEyQjtBQUMzQiwyREFBbUM7QUFDbkMsK0NBQWlEO0FBQ2pELDJDQUFpRDtBQUNqRCx1R0FBNEU7QUFFNUUsTUFBTSxlQUFlLEdBQUcscUNBQXdCLENBQUMscUJBQXFCLENBQUMsQ0FBQztBQUV4RSxNQUFNLFlBQVksR0FBRyxDQUFDO0lBQ2xCLElBQUksbUJBQUUsQ0FBQyxHQUFHLEVBQUU7UUFDUixJQUFJLE9BQU8sR0FBRyxNQUFNLENBQUM7UUFFckIsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ25DLElBQUksR0FBRyxDQUFDLFdBQVcsRUFBRSxLQUFLLE1BQU07Z0JBQzVCLE9BQU8sR0FBRyxHQUFHLENBQUM7UUFDdEIsQ0FBQyxDQUFDLENBQUM7UUFFSCxPQUFPLE9BQU8sQ0FBQztLQUNsQjtJQUVELE9BQU8sTUFBTSxDQUFDO0FBQ2xCLENBQUMsQ0FBQyxFQUFFLENBQUM7QUFHTCxNQUFxQixTQUFTO0lBSzFCO1FBQ0ksSUFBSSxDQUFDLFFBQVEsR0FBTyxJQUFJLENBQUM7UUFDekIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7UUFDekIsSUFBSSxDQUFDLE9BQU8sR0FBUSxLQUFLLENBQUM7SUFDOUIsQ0FBQztJQUVNLEtBQUssQ0FBQyxLQUFLLENBQUUsT0FBZSxFQUFFLFNBQWlCO1FBQ2xELElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLEVBQUU7WUFDaEQsTUFBTSxHQUFHLEdBQVMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ2pELE1BQU0sSUFBSSxHQUFRLEdBQUcsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDMUMsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBYSxDQUFDLENBQUM7WUFFNUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQztZQUVuQyxHQUFHLENBQUMsWUFBWSxDQUFDLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxnQkFBYSxDQUFDLENBQUM7WUFFbEQsSUFBSSxDQUFDLFFBQVEsR0FBRyxvQkFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEdBQUcsQ0FBQyxFQUFFO2dCQUN6QyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sSUFBSSxHQUFHLEVBQUU7b0JBQ3RCLE1BQU0sT0FBTyxHQUFHLEdBQUcsQ0FBQyxLQUFLLElBQUksTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUV6QyxNQUFNLENBQUMsSUFBSSxzQkFBWSxDQUFDLHNCQUFjLENBQUMsd0JBQXdCLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztpQkFDOUU7WUFDTCxDQUFDLENBQUMsQ0FBQztRQUNQLENBQUMsQ0FBQyxDQUFDO1FBRUgsTUFBTSxPQUFPLENBQUMsSUFBSSxDQUFDO1lBQ2YsZUFBSyxDQUFDLFNBQVMsQ0FBQztZQUNoQixJQUFJLENBQUMsWUFBWTtTQUNwQixDQUFDLENBQUM7SUFDUCxDQUFDO0lBRU0sS0FBSyxDQUFDLElBQUk7UUFDYixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztRQUVwQixNQUFNLFdBQVcsR0FBRyxJQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLG1CQUFJLENBQUUsSUFBSSxDQUFDLFFBQXlCLENBQUMsR0FBRyxFQUFFLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBRTFHLE1BQU0sV0FBVyxDQUFDO0lBQ3RCLENBQUM7Q0FDSjtBQTNDRCw0QkEyQ0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGlsZFByb2Nlc3MsIGV4ZWMgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCB7IGRlbGltaXRlciBhcyBwYXRoRGVsaW1pdGVyIH0gZnJvbSAncGF0aCc7XG5pbXBvcnQga2lsbCBmcm9tICd0cmVlLWtpbGwnO1xuaW1wb3J0IE9TIGZyb20gJ29zLWZhbWlseSc7XG5pbXBvcnQgZGVsYXkgZnJvbSAnLi4vdXRpbHMvZGVsYXknO1xuaW1wb3J0IHsgR2VuZXJhbEVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL3J1bnRpbWUnO1xuaW1wb3J0IHsgUlVOVElNRV9FUlJPUlMgfSBmcm9tICcuLi9lcnJvcnMvdHlwZXMnO1xuaW1wb3J0IHJlc29sdmVQYXRoUmVsYXRpdmVseUN3ZCBmcm9tICcuLi91dGlscy9yZXNvbHZlLXBhdGgtcmVsYXRpdmVseS1jd2QnO1xuXG5jb25zdCBNT0RVTEVTX0JJTl9ESVIgPSByZXNvbHZlUGF0aFJlbGF0aXZlbHlDd2QoJy4vbm9kZV9tb2R1bGVzLy5iaW4nKTtcblxuY29uc3QgRU5WX1BBVEhfS0VZID0gKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoT1Mud2luKSB7XG4gICAgICAgIGxldCBwYXRoS2V5ID0gJ1BhdGgnO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKHByb2Nlc3MuZW52KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09ICdwYXRoJylcbiAgICAgICAgICAgICAgICBwYXRoS2V5ID0ga2V5O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcGF0aEtleTtcbiAgICB9XG5cbiAgICByZXR1cm4gJ1BBVEgnO1xufSkoKTtcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXN0ZWRBcHAge1xuICAgIHByaXZhdGUgX2tpbGxlZDogYm9vbGVhbjtcbiAgICBwdWJsaWMgZXJyb3JQcm9taXNlOiBudWxsIHwgUHJvbWlzZTx2b2lkPjtcbiAgICBwcml2YXRlIF9wcm9jZXNzOiBudWxsIHwgQ2hpbGRQcm9jZXNzO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgICAgdGhpcy5fcHJvY2VzcyAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLmVycm9yUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2tpbGxlZCAgICAgID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIHN0YXJ0IChjb21tYW5kOiBzdHJpbmcsIGluaXREZWxheTogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRoaXMuZXJyb3JQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW52ICAgICAgID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvY2Vzcy5lbnYpO1xuICAgICAgICAgICAgY29uc3QgcGF0aCAgICAgID0gZW52W0VOVl9QQVRIX0tFWV0gfHwgJyc7XG4gICAgICAgICAgICBjb25zdCBwYXRoUGFydHMgPSBwYXRoLnNwbGl0KHBhdGhEZWxpbWl0ZXIpO1xuXG4gICAgICAgICAgICBwYXRoUGFydHMudW5zaGlmdChNT0RVTEVTX0JJTl9ESVIpO1xuXG4gICAgICAgICAgICBlbnZbRU5WX1BBVEhfS0VZXSA9IHBhdGhQYXJ0cy5qb2luKHBhdGhEZWxpbWl0ZXIpO1xuXG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzID0gZXhlYyhjb21tYW5kLCB7IGVudiB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fa2lsbGVkICYmIGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZXJyLnN0YWNrIHx8IFN0cmluZyhlcnIpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgR2VuZXJhbEVycm9yKFJVTlRJTUVfRVJST1JTLnRlc3RlZEFwcEZhaWxlZFdpdGhFcnJvciwgbWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgZGVsYXkoaW5pdERlbGF5KSxcbiAgICAgICAgICAgIHRoaXMuZXJyb3JQcm9taXNlXG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBraWxsICgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgdGhpcy5fa2lsbGVkID0gdHJ1ZTtcblxuICAgICAgICBjb25zdCBraWxsUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ga2lsbCgodGhpcy5fcHJvY2VzcyBhcyBDaGlsZFByb2Nlc3MpLnBpZCwgJ1NJR1RFUk0nLCByZXNvbHZlKSk7XG5cbiAgICAgICAgYXdhaXQga2lsbFByb21pc2U7XG4gICAgfVxufVxuIl19